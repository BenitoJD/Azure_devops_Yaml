pool:
  name: ccoe-nprod-windows-mdp-01

trigger: none

name: $(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

parameters:
  - name: DeployIT1
    displayName: 'Deploy IT1.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT2
    displayName: 'Deploy IT2.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT3
    displayName: 'Deploy IT3.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT4
    displayName: 'Deploy IT4.API.MasterData.com'
    type: boolean
    default: true

variables:
  BuildNumber: '$(Build.BuildNumber)'
  BranchName: '$(Build.SourceBranchName)'
  BuildVersion: '$(Build.BuildId)'

  DeploymentBasePath: 'D:\\Deployments\\ServiceLayer'
  BackupBasePath: 'D:\\Backups\\ServiceLayer'

  Deploy.IT1: ${{ parameters.DeployIT1 }}
  Deploy.IT2: ${{ parameters.DeployIT2 }}
  Deploy.IT3: ${{ parameters.DeployIT3 }}
  Deploy.IT4: ${{ parameters.DeployIT4 }}

  SelectedSites: ''

  # IIS site/app definitions for ServiceLayer WebAPI
  Stakeholder1.Name: 'IT1.API.MasterData.com'
  Stakeholder1.Port: '8191'
  Stakeholder1.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT1.API.MasterData.com'
  Stakeholder1.AppPoolName: 'IT1_API_MD_AppPool'

  Stakeholder2.Name: 'IT2.API.MasterData.com'
  Stakeholder2.Port: '8192'
  Stakeholder2.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT2.API.MasterData.com'
  Stakeholder2.AppPoolName: 'IT2_API_MD_AppPool'

  Stakeholder3.Name: 'IT3.API.MasterData.com'
  Stakeholder3.Port: '8193'
  Stakeholder3.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT3.API.MasterData.com'
  Stakeholder3.AppPoolName: 'IT3_API_MD_AppPool'

  Stakeholder4.Name: 'IT4.API.MasterData.com'
  Stakeholder4.Port: '8194'
  Stakeholder4.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT4.API.MasterData.com'
  Stakeholder4.AppPoolName: 'IT4_API_MD_AppPool'

resources:
  pipelines:
   - pipeline: 'MasterData.ServiceLayer'
     project: 'MasterData'
     source: 'MasterData.ServiceLayer'
     branch: 'MDVersionUpgrade/Lonestar'

stages:
  - stage: Initialize
    displayName: 'Initialize and Select Targets'
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Initialize_Env
        displayName: 'Initialize'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: PowerShell@2
                  displayName: 'Build Information'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Branch: $(BranchName)"
                      Write-Host "Build: $(BuildNumber)"
                      Write-Host "Version: $(BuildVersion)"
                      Write-Host "IT1: $(Deploy.IT1) | IT2: $(Deploy.IT2) | IT3: $(Deploy.IT3) | IT4: $(Deploy.IT4)"
                - task: PowerShell@2
                  displayName: 'Set SelectedSites variable'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $selectedSites = @()
                      if ("$(Deploy.IT1)" -eq "true") { $selectedSites += "IT1.API.MasterData.com" }
                      if ("$(Deploy.IT2)" -eq "true") { $selectedSites += "IT2.API.MasterData.com" }
                      if ("$(Deploy.IT3)" -eq "true") { $selectedSites += "IT3.API.MasterData.com" }
                      if ("$(Deploy.IT4)" -eq "true") { $selectedSites += "IT4.API.MasterData.com" }
                      $sitesList = $selectedSites -join " "
                      Write-Host "##vso[task.setvariable variable=SelectedSites]$sitesList"
                      $date = Get-Date -Format "yyyyMMdd"
                      $definitionName = $env:BUILD_DEFINITIONNAME
                      $branchName = $env:BUILD_SOURCEBRANCHNAME
                      if (-not $definitionName -or $definitionName.Trim() -eq '') { $definitionName = 'Build' }
                      if (-not $branchName -or $branchName.Trim() -eq '') { $branchName = 'UnknownBranch' }
                      $newName = "${definitionName}_${branchName}_$date_Sites[$sitesList]"
                      Write-Host "##vso[build.updatebuildnumber]$newName"

  - stage: AcquireArtifacts
    displayName: 'Acquire Artifacts'
    dependsOn: Initialize
    condition: succeeded()
    jobs:
      - deployment: Acquire
        displayName: 'Download and Prepare Artifacts'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - download: 'MasterData.ServiceLayer'
                  displayName: 'Download artifacts'
                  artifact: 'webapi-drop'
                - task: PowerShell@2
                  displayName: 'Create required directories'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $directories = @()
                      if ("$(Deploy.IT1)" -eq "true") { $directories += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.IT2)" -eq "true") { $directories += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.IT3)" -eq "true") { $directories += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.IT4)" -eq "true") { $directories += "$(Stakeholder4.PhysicalPath)" }
                      $directories += "$(DeploymentBasePath)"
                      foreach ($dir in $directories) { if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null } }
                - task: ExtractFiles@1
                  displayName: 'Extract artifacts'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/MasterData.ServiceLayer/webapi-drop/*.zip'
                    destinationFolder: '$(DeploymentBasePath)'
                    cleanDestinationFolder: true
                    overwriteExistingFiles: true

  - stage: Backup
    displayName: 'Backup Current Deployments'
    dependsOn: AcquireArtifacts
    condition: succeeded()
    jobs:
      - deployment: Backup_Sites
        displayName: 'Backup selected sites'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Backup active content'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      if (-not (Test-Path "$(BackupBasePath)")) { New-Item -ItemType Directory -Path "$(BackupBasePath)" -Force | Out-Null }
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -eq "true") {
                          $buildId = "$(BuildVersion)"
                          $branch = "$(BranchName)"
                          $branchSafe = ($branch -replace "[^A-Za-z0-9._-]", "_")
                          $namePart = "$($s.Name)_$branchSafe_$buildId_$timestamp"
                          if ($namePart.Length -gt 150) { $namePart = $namePart.Substring(0,150) }
                          $backupPath = Join-Path "$(BackupBasePath)" $namePart
                          if (Test-Path $s.Path) {
                            New-Item -ItemType Directory -Path $backupPath -Force | Out-Null
                            Copy-Item -Path "$($s.Path)\*" -Destination $backupPath -Recurse -Force
                          }
                        }
                      }

  - stage: ConfigureIIS
    displayName: 'Configure IIS'
    dependsOn: Backup
    condition: succeeded()
    jobs:
      - deployment: Configure_IIS
        displayName: 'Ensure sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Ensure IIS configuration'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $useAppCmd = $false
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $useAppCmd = $true }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Port="$(Stakeholder1.Port)"; Path="$(Stakeholder1.PhysicalPath)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Port="$(Stakeholder2.Port)"; Path="$(Stakeholder2.PhysicalPath)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Port="$(Stakeholder3.Port)"; Path="$(Stakeholder3.PhysicalPath)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Port="$(Stakeholder4.Port)"; Path="$(Stakeholder4.PhysicalPath)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($useAppCmd) {
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" add apppool /name:$($s.AppPool) /managedRuntimeVersion:"" /managedPipelineMode:Integrated } catch {}
                          try {
                            & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" add site /name:$($s.Name) /physicalPath:$($s.Path) /bindings:http/*:$($s.Port):
                            & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" set app "$($s.Name)/" /applicationPool:$($s.AppPool)
                          } catch {}
                        } else {
                          if (-not (Test-Path "IIS:\\AppPools\\$($s.AppPool)")) { New-WebAppPool -Name $s.AppPool | Out-Null }
                          # Kestrel-hosted ASP.NET Core does not require .NET CLR in app pool
                          Set-ItemProperty "IIS:\\AppPools\\$($s.AppPool)" -Name managedRuntimeVersion -Value ""
                          Set-ItemProperty "IIS:\\AppPools\\$($s.AppPool)" -Name managedPipelineMode -Value "Integrated"
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) {
                            Set-ItemProperty "IIS:\\Sites\\$($s.Name)" -Name applicationPool -Value $s.AppPool
                            Set-ItemProperty "IIS:\\Sites\\$($s.Name)" -Name physicalPath -Value $s.Path
                            $desired = "*:$($s.Port):"
                            $httpBindings = Get-WebBinding -Name $s.Name -Protocol "http" -ErrorAction SilentlyContinue
                            $matching = @(); if ($httpBindings) { $matching = $httpBindings | Where-Object { $_.bindingInformation -eq $desired } }
                            if (-not $matching -or $matching.Count -eq 0) { New-WebBinding -Name $s.Name -Protocol "http" -Port $s.Port -IPAddress "*" -HostHeader "" }
                          } else {
                            New-Website -Name $s.Name -PhysicalPath $s.Path -ApplicationPool $s.AppPool -Port $s.Port | Out-Null
                          }
                        }
                      }

  - stage: DeployFiles
    displayName: 'Deploy Files'
    dependsOn: ConfigureIIS
    condition: succeeded()
    jobs:
      - deployment: Deploy_Content
        displayName: 'Copy application files'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Copy files to sites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if (Test-Path $s.Dest) { Get-ChildItem -Path $s.Dest -Exclude "App_Data" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
                        Copy-Item -Path "$($s.Source)\*" -Destination $s.Dest -Recurse -Force
                      }

  - stage: InjectConfiguration
    displayName: 'Inject appsettings.json Configuration'
    dependsOn: DeployFiles
    condition: succeeded()
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Inject_Config
        displayName: 'Update appsettings.json from variable groups'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                # IT1 – diagnostics: show available env vars and mapped names
                - task: PowerShell@2
                  displayName: 'Diagnostics: env → mapped variables - IT1'
                  condition: and(succeeded(), eq(variables['Deploy.IT1'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "[Diag IT1] Scanning Env: for prefixes SIT_IT1_API. and SIT_IT1_API_"
                      $found = @()
                      $remap = @{}
                      $appPath = Join-Path "$(Stakeholder4.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Normalize-PathAgainstJson($jsonText, $dotPath) { if (-not $jsonText) { return $dotPath } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $dotPath } $segments = $dotPath.Split('.'); $cur = $obj; $norm = @(); foreach ($seg in $segments) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $dotPath }; $norm += $match; $cur = $cur.$match } else { return $dotPath } } return ($norm -join '.') }
                      function Find-LeafPaths($jsonText, $leaf) { if (-not $jsonText) { return @() } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() } $results = @(); function Recurse($node,$prefix){ if ($node -is [pscustomobject]) { foreach ($p in $node.PSObject.Properties) { $path = if ($prefix){"$prefix.$($p.Name)"}else{$p.Name}; if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }; Recurse $p.Value $path } } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) { foreach ($e in $node) { Recurse $e $prefix } } }; Recurse $obj ''; return $results }
                      $appPath = Join-Path "$(Stakeholder4.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Find-LeafPaths($jsonText, $leaf) { if (-not $jsonText) { return @() } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() } $results = @(); function Recurse($node,$prefix){ if ($node -is [pscustomobject]) { foreach ($p in $node.PSObject.Properties) { $path = if ($prefix){"$prefix.$($p.Name)"}else{$p.Name}; if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }; Recurse $p.Value $path } } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) { foreach ($e in $node) { Recurse $e $prefix } } }; Recurse $obj ''; return $results }
                      $appPath = Join-Path "$(Stakeholder3.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Normalize-PathAgainstJson($jsonText, $dotPath) { if (-not $jsonText) { return $dotPath } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $dotPath } $segments = $dotPath.Split('.'); $cur = $obj; $norm = @(); foreach ($seg in $segments) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $dotPath }; $norm += $match; $cur = $cur.$match } else { return $dotPath } } return ($norm -join '.') }
                      function Find-LeafPaths($jsonText, $leaf) { if (-not $jsonText) { return @() } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() } $results = @(); function Recurse($node,$prefix){ if ($node -is [pscustomobject]) { foreach ($p in $node.PSObject.Properties) { $path = if ($prefix){"$prefix.$($p.Name)"}else{$p.Name}; if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }; Recurse $p.Value $path } } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) { foreach ($e in $node) { Recurse $e $prefix } } }; Recurse $obj ''; return $results }
                      $appPath = Join-Path "$(Stakeholder3.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Find-LeafPaths($jsonText, $leaf) { if (-not $jsonText) { return @() } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() } $results = @(); function Recurse($node,$prefix){ if ($node -is [pscustomobject]) { foreach ($p in $node.PSObject.Properties) { $path = if ($prefix){"$prefix.$($p.Name)"}else{$p.Name}; if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }; Recurse $p.Value $path } } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) { foreach ($e in $node) { Recurse $e $prefix } } }; Recurse $obj ''; return $results }
                      $appPath = Join-Path "$(Stakeholder2.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Normalize-PathAgainstJson($jsonText, $dotPath) { if (-not $jsonText) { return $dotPath } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $dotPath } $segments = $dotPath.Split('.'); $cur = $obj; $norm = @(); foreach ($seg in $segments) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $dotPath }; $norm += $match; $cur = $cur.$match } else { return $dotPath } } return ($norm -join '.') }
                      function Find-LeafPaths($jsonText, $leaf) { if (-not $jsonText) { return @() } try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() } $results = @(); function Recurse($node,$prefix){ if ($node -is [pscustomobject]) { foreach ($p in $node.PSObject.Properties) { $path = if ($prefix){"$prefix.$($p.Name)"}else{$p.Name}; if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }; Recurse $p.Value $path } } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) { foreach ($e in $node) { Recurse $e $prefix } } }; Recurse $obj ''; return $results }
                      $appPath = Join-Path "$(Stakeholder2.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Find-LeafPaths($jsonText, $leaf) {
                        if (-not $jsonText) { return @() }
                        try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() }
                        $results = @()
                        function Recurse($node, $prefix) {
                          if ($node -is [pscustomobject]) {
                            foreach ($p in $node.PSObject.Properties) {
                              $path = if ($prefix) { "$prefix.$($p.Name)" } else { $p.Name }
                              if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }
                              Recurse $p.Value $path
                            }
                          } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) {
                            foreach ($e in $node) { Recurse $e $prefix }
                          }
                        }
                        Recurse $obj ''
                        return $results
                      }
                      $appPath = Join-Path "$(Stakeholder1.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Normalize-PathAgainstJson($jsonText, $dotPath) {
                        if (-not $jsonText) { return $dotPath }
                        try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $dotPath }
                        $segments = $dotPath.Split('.')
                        $cur = $obj; $norm = @()
                        foreach ($seg in $segments) {
                          if ($cur -is [pscustomobject]) {
                            $names = $cur.PSObject.Properties.Name
                            $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1
                            if (-not $match) { return $dotPath }
                            $norm += $match; $cur = $cur.$match
                          } else { return $dotPath }
                        }
                        return ($norm -join '.')
                      }
                      function Find-LeafPaths($jsonText, $leaf) {
                        if (-not $jsonText) { return @() }
                        try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() }
                        $results = @()
                        function Recurse($node, $prefix) {
                          if ($node -is [pscustomobject]) {
                            foreach ($p in $node.PSObject.Properties) {
                              $path = if ($prefix) { "$prefix.$($p.Name)" } else { $p.Name }
                              if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }
                              Recurse $p.Value $path
                            }
                          } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) {
                            foreach ($e in $node) { Recurse $e $prefix }
                          }
                        }
                        Recurse $obj ''
                        return $results
                      }
                      $appPath = Join-Path "$(Stakeholder1.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      function Find-LeafPaths($jsonText, $leaf) {
                        if (-not $jsonText) { return @() }
                        try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return @() }
                        $results = @()
                        function Recurse($node, $prefix) {
                          if ($node -is [pscustomobject]) {
                            foreach ($p in $node.PSObject.Properties) {
                              $path = if ($prefix) { "$prefix.$($p.Name)" } else { $p.Name }
                              if ($p.MemberType -eq 'NoteProperty' -and ($p.Name -ieq $leaf)) { $script:results += $path }
                              Recurse $p.Value $path
                            }
                          } elseif ($node -is [System.Collections.IEnumerable] -and -not ($node -is [string])) {
                            foreach ($e in $node) { Recurse $e $prefix }
                          }
                        }
                        Recurse $obj ''
                        return $results
                      }
                      $appPath = Join-Path "$(Stakeholder1.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      foreach ($p in @('SIT_IT1_API.', 'SIT_IT1_API_')) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $mapped = $suffix -replace '__','.' # keep single underscores
                            $hits = @()
                            if ($mapped -notmatch '\\.' -and $jsonText) { $hits = Find-LeafPaths $jsonText $mapped; if ($hits.Count -eq 1) { $mapped = $hits[0] } }
                            $mapType = if ($suffix -match '__' -or $mapped -match '\\.') { 'ExactPath' } elseif ($hits.Count -eq 1) { 'AutoLeafUnique' } elseif ($hits.Count -gt 1) { 'Ambiguous' } else { 'NoMatch' }
                            $masked = if ($_.Value.Length -gt 4) { ($_.Value.Substring(0,2) + '***' + $_.Value.Substring($_.Value.Length-2)) } else { '***' }
                            $found += [PSCustomObject]@{ EnvName = $_.Name; Mapped = $mapped; MapType=$mapType; Hits=$hits.Count; ValueSample = $masked }
                          }
                      }
                      Write-Host ("[Diag IT1] VarsFound={0}" -f $found.Count)
                      $found | Sort-Object MapType, Mapped | Format-Table EnvName,MapType,Hits,Mapped,ValueSample -AutoSize | Out-String -Width 200 | Write-Host
                      $amb = @($found | Where-Object { $_.MapType -eq 'Ambiguous' })
                      $miss = @($found | Where-Object { $_.MapType -eq 'NoMatch' })
                      $auto = @($found | Where-Object { $_.MapType -eq 'AutoLeafUnique' })
                      $exact = @($found | Where-Object { $_.MapType -eq 'ExactPath' })
                      Write-Host ("[Diag IT1] Summary: Exact={0} Auto={1} Ambiguous={2} NoMatch={3}" -f $exact.Count,$auto.Count,$amb.Count,$miss.Count)
                      if ($amb.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT1] Ambiguous leaf names:"; $amb | ForEach-Object { Write-Host ("  - {0} → {1} (hits={2})" -f $_.EnvName,$_.Mapped,$_.Hits) } }
                      if ($miss.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT1] NoMatch leaf names:"; $miss | ForEach-Object { Write-Host ("  - {0} (leaf='{1}')" -f $_.EnvName, ($_.EnvName -replace '^SIT_IT1_API[._]','')) } }
                # IT1 – prepare variables without prefix and run File Transform
                - task: PowerShell@2
                  displayName: 'Prepare variables for transform - IT1'
                  condition: and(succeeded(), eq(variables['Deploy.IT1'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefixes = @('SIT_IT1_API.', 'SIT_IT1_API_')
                      $remap = @{}
                      foreach ($p in $prefixes) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $name = $suffix -replace '__','.' # keep single underscores
                            if ($name -notmatch '\\.' -and $remap.ContainsKey($name.ToUpper())) { $name = $remap[$name.ToUpper()] } elseif ($name -notmatch '\\.' -and $jsonText) {
                              $hits = Find-LeafPaths $jsonText $name
                              if ($hits.Count -eq 1) { $name = $hits[0] }
                            }
                            if ($jsonText -and $name -match '\\.') { $name = Normalize-PathAgainstJson $jsonText $name }
                            Write-Host "##vso[task.setvariable variable=$name]$($_.Value)"
                          }
                      }
                      # Pre-transform capture and existence check
                      $appPath = Join-Path "$(Stakeholder1.PhysicalPath)" 'appsettings.json'
                      if (Test-Path $appPath) {
                        $before = Get-Content $appPath -Raw
                        $before | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT1_appsettings_before.json') -Encoding UTF8 -Force
                        # Build the mapped list again to persist
                        $mapped = @()
                        foreach ($pfx in $prefixes) {
                          Get-ChildItem Env: |
                            Where-Object { $_.Name -like "$pfx*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                            ForEach-Object {
                              $suf = $_.Name.Substring($pfx.Length)
                              $n = $suf -replace '__','.'
                              if ($n -notmatch '\\.' -and $remap.ContainsKey($n.ToUpper())) { $n = $remap[$n.ToUpper()] }
                              $mapped += $n
                            }
                        }
                        $mapped | Sort-Object -Unique | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT1_mapped.txt') -Encoding UTF8 -Force
                        # Existence report
                        function Test-JsonPath($jsonText, $dotPath) {
                          try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $false }
                          $cur = $obj
                          foreach ($seg in $dotPath.Split('.')) {
                            if ($cur -is [pscustomobject]) {
                              $names = $cur.PSObject.Properties.Name
                              $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1
                              if (-not $match) { return $false }
                              $cur = $cur.$match
                            } else { return $false }
                          }
                          return $true
                        }
                        $exists = @(); $notExists = @()
                        foreach ($mp in ($mapped | Sort-Object -Unique)) { if (Test-JsonPath $before $mp) { $exists += $mp } else { $notExists += $mp } }
                        Write-Host ("[Diag IT1] Paths existing pre-transform: {0}" -f $exists.Count)
                        if ($notExists.Count -gt 0) { Write-Host '[Diag IT1] Paths NOT found pre-transform:'; $notExists | ForEach-Object { Write-Host "  - $_" } }
                      } else { Write-Host '[Diag IT1] appsettings.json not found for pre-transform capture' }
                - task: FileTransform@1
                  displayName: 'JSON variable substitution - IT1'
                  condition: and(succeeded(), eq(variables['Deploy.IT1'], 'true'))
                  inputs:
                    folderPath: '$(Stakeholder1.PhysicalPath)'
                    fileType: 'json'
                    targetFiles: 'appsettings.json'
                - task: PowerShell@2
                  displayName: 'Post-transform diagnostics - IT1'
                  condition: and(succeeded(), eq(variables['Deploy.IT1'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $path = Join-Path "$(Stakeholder1.PhysicalPath)" 'appsettings.json'
                      if (-not (Test-Path $path)) { Write-Host '[Diag IT1] appsettings.json missing post-transform'; exit 0 }
                      $beforePath = Join-Path $env:PIPELINE_WORKSPACE 'IT1_appsettings_before.json'
                      $mapPath    = Join-Path $env:PIPELINE_WORKSPACE 'IT1_mapped.txt'
                      if (-not (Test-Path $beforePath) -or -not (Test-Path $mapPath)) { Write-Host '[Diag IT1] Missing pre-transform artifacts'; exit 0 }
                      $before = Get-Content $beforePath -Raw
                      $after  = Get-Content $path -Raw
                      $mapped = Get-Content $mapPath
                      function Get-JsonValue($jsonText, $dotPath) {
                        try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $null }
                        $cur = $obj
                        foreach ($seg in $dotPath.Split('.')) {
                          if ($cur -is [pscustomobject]) {
                            $names = $cur.PSObject.Properties.Name
                            $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1
                            if (-not $match) { return $null }
                            $cur = $cur.$match
                          } else { return $null }
                        }
                        return $cur
                      }
                      $changed = @(); $unchanged = @(); $missing = @()
                      foreach ($p in $mapped) {
                        $b = Get-JsonValue $before $p
                        $a = Get-JsonValue $after  $p
                        if ($null -eq $b -and $null -eq $a) { $missing += $p; continue }
                        if (("$b") -ne ("$a")) { $changed += [PSCustomObject]@{ Path=$p; Before="$b"; After="$a" } }
                        else { $unchanged += $p }
                      }
                      Write-Host ("[Diag IT1] Changed={0} Unchanged={1} MissingPaths={2}" -f $changed.Count,$unchanged.Count,$missing.Count)
                      if ($changed.Count -gt 0) { $changed | Format-Table -AutoSize | Out-String -Width 200 | Write-Host }
                      if ($missing.Count -gt 0) { Write-Host '[Diag IT1] Missing:'; $missing | Sort-Object | ForEach-Object { Write-Host "  - $_" } }

                # IT2 – diagnostics: show available env vars and mapped names
                - task: PowerShell@2
                  displayName: 'Diagnostics: env → mapped variables - IT2'
                  condition: and(succeeded(), eq(variables['Deploy.IT2'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "[Diag IT2] Scanning Env: for prefixes SIT_IT2_API. and SIT_IT2_API_"
                      $found = @()
                      $remap = @{}
                      $appPath = Join-Path "$(Stakeholder2.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      foreach ($p in @('SIT_IT2_API.', 'SIT_IT2_API_')) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $mapped = $suffix -replace '__','.'
                            $hits = @(); if ($mapped -notmatch '\\.' -and $jsonText) { $hits = Find-LeafPaths $jsonText $mapped; if ($hits.Count -eq 1) { $mapped = $hits[0] } }
                            $mapType = if ($suffix -match '__' -or $mapped -match '\\.') { 'ExactPath' } elseif ($hits.Count -eq 1) { 'AutoLeafUnique' } elseif ($hits.Count -gt 1) { 'Ambiguous' } else { 'NoMatch' }
                            $masked = if ($_.Value.Length -gt 4) { ($_.Value.Substring(0,2) + '***' + $_.Value.Substring($_.Value.Length-2)) } else { '***' }
                            $found += [PSCustomObject]@{ EnvName = $_.Name; Mapped = $mapped; MapType=$mapType; Hits=$hits.Count; ValueSample = $masked }
                          }
                      }
                      Write-Host ("[Diag IT2] VarsFound={0}" -f $found.Count)
                      $found | Sort-Object MapType, Mapped | Format-Table EnvName,MapType,Hits,Mapped,ValueSample -AutoSize | Out-String -Width 200 | Write-Host
                      $amb = @($found | Where-Object { $_.MapType -eq 'Ambiguous' })
                      $miss = @($found | Where-Object { $_.MapType -eq 'NoMatch' })
                      $auto = @($found | Where-Object { $_.MapType -eq 'AutoLeafUnique' })
                      $exact = @($found | Where-Object { $_.MapType -eq 'ExactPath' })
                      Write-Host ("[Diag IT2] Summary: Exact={0} Auto={1} Ambiguous={2} NoMatch={3}" -f $exact.Count,$auto.Count,$amb.Count,$miss.Count)
                      if ($amb.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT2] Ambiguous leaf names:"; $amb | ForEach-Object { Write-Host ("  - {0} → {1} (hits={2})" -f $_.EnvName,$_.Mapped,$_.Hits) } }
                      if ($miss.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT2] NoMatch leaf names:"; $miss | ForEach-Object { Write-Host ("  - {0} (leaf='{1}')" -f $_.EnvName, ($_.EnvName -replace '^SIT_IT2_API[._]','')) } }
                # IT2 – prepare variables without prefix and run File Transform
                - task: PowerShell@2
                  displayName: 'Prepare variables for transform - IT2'
                  condition: and(succeeded(), eq(variables['Deploy.IT2'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefixes = @('SIT_IT2_API.', 'SIT_IT2_API_')
                      $remap = @{}
                      foreach ($p in $prefixes) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $name = $suffix -replace '__','.'
                            if ($name -notmatch '\\.' -and $remap.ContainsKey($name.ToUpper())) { $name = $remap[$name.ToUpper()] } elseif ($name -notmatch '\\.' -and $jsonText) { $hits = Find-LeafPaths $jsonText $name; if ($hits.Count -eq 1) { $name = $hits[0] } }
                            if ($jsonText -and $name -match '\\.') { $name = Normalize-PathAgainstJson $jsonText $name }
                            Write-Host "##vso[task.setvariable variable=$name]$($_.Value)"
                          }
                      }
                      $appPath = Join-Path "$(Stakeholder2.PhysicalPath)" 'appsettings.json'
                      if (Test-Path $appPath) {
                        $before = Get-Content $appPath -Raw
                        $before | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT2_appsettings_before.json') -Encoding UTF8 -Force
                        $mapped = @()
                        foreach ($pfx in $prefixes) {
                          Get-ChildItem Env: |
                            Where-Object { $_.Name -like "$pfx*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                            ForEach-Object {
                              $suf = $_.Name.Substring($pfx.Length)
                              $n = $suf -replace '__','.'
                              if ($n -notmatch '\\.' -and $remap.ContainsKey($n.ToUpper())) { $n = $remap[$n.ToUpper()] }
                              $mapped += $n
                            }
                        }
                        $mapped | Sort-Object -Unique | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT2_mapped.txt') -Encoding UTF8 -Force
                        function Test-JsonPath($jsonText, $dotPath) { try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $false } $cur = $obj; foreach ($seg in $dotPath.Split('.')) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $false }; $cur = $cur.$match } else { return $false } } return $true }
                        $exists = @(); $notExists = @(); foreach ($mp in ($mapped | Sort-Object -Unique)) { if (Test-JsonPath $before $mp) { $exists += $mp } else { $notExists += $mp } }
                        Write-Host ("[Diag IT2] Paths existing pre-transform: {0}" -f $exists.Count)
                        if ($notExists.Count -gt 0) { Write-Host '[Diag IT2] Paths NOT found pre-transform:'; $notExists | ForEach-Object { Write-Host "  - $_" } }
                      } else { Write-Host '[Diag IT2] appsettings.json not found for pre-transform capture' }
                - task: FileTransform@1
                  displayName: 'JSON variable substitution - IT2'
                  condition: and(succeeded(), eq(variables['Deploy.IT2'], 'true'))
                  inputs:
                    folderPath: '$(Stakeholder2.PhysicalPath)'
                    fileType: 'json'
                    targetFiles: 'appsettings.json'
                - task: PowerShell@2
                  displayName: 'Post-transform diagnostics - IT2'
                  condition: and(succeeded(), eq(variables['Deploy.IT2'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $path = Join-Path "$(Stakeholder2.PhysicalPath)" 'appsettings.json'
                      if (-not (Test-Path $path)) { Write-Host '[Diag IT2] appsettings.json missing post-transform'; exit 0 }
                      $beforePath = Join-Path $env:PIPELINE_WORKSPACE 'IT2_appsettings_before.json'
                      $mapPath    = Join-Path $env:PIPELINE_WORKSPACE 'IT2_mapped.txt'
                      if (-not (Test-Path $beforePath) -or -not (Test-Path $mapPath)) { Write-Host '[Diag IT2] Missing pre-transform artifacts'; exit 0 }
                      $before = Get-Content $beforePath -Raw
                      $after  = Get-Content $path -Raw
                      $mapped = Get-Content $mapPath
                      function Get-JsonValue($jsonText, $dotPath) { try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $null } $cur = $obj; foreach ($seg in $dotPath.Split('.')) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $null }; $cur = $cur.$match } else { return $null } } return $cur }
                      $changed = @(); $unchanged = @(); $missing = @()
                      foreach ($p in $mapped) {
                        $b = Get-JsonValue $before $p
                        $a = Get-JsonValue $after  $p
                        if ($null -eq $b -and $null -eq $a) { $missing += $p; continue }
                        if (("$b") -ne ("$a")) { $changed += [PSCustomObject]@{ Path=$p; Before="$b"; After="$a" } }
                        else { $unchanged += $p }
                      }
                      Write-Host ("[Diag IT2] Changed={0} Unchanged={1} MissingPaths={2}" -f $changed.Count,$unchanged.Count,$missing.Count)
                      if ($changed.Count -gt 0) { $changed | Format-Table -AutoSize | Out-String -Width 200 | Write-Host }
                      if ($missing.Count -gt 0) { Write-Host '[Diag IT2] Missing:'; $missing | Sort-Object | ForEach-Object { Write-Host "  - $_" } }

                # IT3 – diagnostics: show available env vars and mapped names
                - task: PowerShell@2
                  displayName: 'Diagnostics: env → mapped variables - IT3'
                  condition: and(succeeded(), eq(variables['Deploy.IT3'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "[Diag IT3] Scanning Env: for prefixes SIT_IT3_API. and SIT_IT3_API_"
                      $found = @()
                      $remap = @{}
                      $appPath = Join-Path "$(Stakeholder3.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      foreach ($p in @('SIT_IT3_API.', 'SIT_IT3_API_')) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $mapped = $suffix -replace '__','.'
                            $hits = @(); if ($mapped -notmatch '\\.' -and $jsonText) { $hits = Find-LeafPaths $jsonText $mapped; if ($hits.Count -eq 1) { $mapped = $hits[0] } }
                            $mapType = if ($suffix -match '__' -or $mapped -match '\\.') { 'ExactPath' } elseif ($hits.Count -eq 1) { 'AutoLeafUnique' } elseif ($hits.Count -gt 1) { 'Ambiguous' } else { 'NoMatch' }
                            $masked = if ($_.Value.Length -gt 4) { ($_.Value.Substring(0,2) + '***' + $_.Value.Substring($_.Value.Length-2)) } else { '***' }
                            $found += [PSCustomObject]@{ EnvName = $_.Name; Mapped = $mapped; MapType=$mapType; Hits=$hits.Count; ValueSample = $masked }
                          }
                      }
                      Write-Host ("[Diag IT3] VarsFound={0}" -f $found.Count)
                      $found | Sort-Object MapType, Mapped | Format-Table EnvName,MapType,Hits,Mapped,ValueSample -AutoSize | Out-String -Width 200 | Write-Host
                      $amb = @($found | Where-Object { $_.MapType -eq 'Ambiguous' })
                      $miss = @($found | Where-Object { $_.MapType -eq 'NoMatch' })
                      $auto = @($found | Where-Object { $_.MapType -eq 'AutoLeafUnique' })
                      $exact = @($found | Where-Object { $_.MapType -eq 'ExactPath' })
                      Write-Host ("[Diag IT3] Summary: Exact={0} Auto={1} Ambiguous={2} NoMatch={3}" -f $exact.Count,$auto.Count,$amb.Count,$miss.Count)
                      if ($amb.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT3] Ambiguous leaf names:"; $amb | ForEach-Object { Write-Host ("  - {0} → {1} (hits={2})" -f $_.EnvName,$_.Mapped,$_.Hits) } }
                      if ($miss.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT3] NoMatch leaf names:"; $miss | ForEach-Object { Write-Host ("  - {0} (leaf='{1}')" -f $_.EnvName, ($_.EnvName -replace '^SIT_IT3_API[._]','')) } }
                # IT3 – prepare variables without prefix and run File Transform
                - task: PowerShell@2
                  displayName: 'Prepare variables for transform - IT3'
                  condition: and(succeeded(), eq(variables['Deploy.IT3'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefixes = @('SIT_IT3_API.', 'SIT_IT3_API_')
                      $remap = @{}
                      foreach ($p in $prefixes) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $name = $suffix -replace '__','.'
                            if ($name -notmatch '\\.' -and $remap.ContainsKey($name.ToUpper())) { $name = $remap[$name.ToUpper()] } elseif ($name -notmatch '\\.' -and $jsonText) { $hits = Find-LeafPaths $jsonText $name; if ($hits.Count -eq 1) { $name = $hits[0] } }
                            if ($jsonText -and $name -match '\\.') { $name = Normalize-PathAgainstJson $jsonText $name }
                            Write-Host "##vso[task.setvariable variable=$name]$($_.Value)"
                          }
                      }
                      $appPath = Join-Path "$(Stakeholder3.PhysicalPath)" 'appsettings.json'
                      if (Test-Path $appPath) {
                        $before = Get-Content $appPath -Raw
                        $before | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT3_appsettings_before.json') -Encoding UTF8 -Force
                        $mapped = @()
                        foreach ($pfx in $prefixes) {
                          Get-ChildItem Env: |
                            Where-Object { $_.Name -like "$pfx*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                            ForEach-Object {
                              $suf = $_.Name.Substring($pfx.Length)
                              $n = $suf -replace '__','.'
                              if ($n -notmatch '\\.' -and $remap.ContainsKey($n.ToUpper())) { $n = $remap[$n.ToUpper()] }
                              $mapped += $n
                            }
                        }
                        $mapped | Sort-Object -Unique | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT3_mapped.txt') -Encoding UTF8 -Force
                        function Test-JsonPath($jsonText, $dotPath) { try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $false } $cur = $obj; foreach ($seg in $dotPath.Split('.')) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $false }; $cur = $cur.$match } else { return $false } } return $true }
                        $exists = @(); $notExists = @(); foreach ($mp in ($mapped | Sort-Object -Unique)) { if (Test-JsonPath $before $mp) { $exists += $mp } else { $notExists += $mp } }
                        Write-Host ("[Diag IT3] Paths existing pre-transform: {0}" -f $exists.Count)
                        if ($notExists.Count -gt 0) { Write-Host '[Diag IT3] Paths NOT found pre-transform:'; $notExists | ForEach-Object { Write-Host "  - $_" } }
                      } else { Write-Host '[Diag IT3] appsettings.json not found for pre-transform capture' }
                - task: FileTransform@1
                  displayName: 'JSON variable substitution - IT3'
                  condition: and(succeeded(), eq(variables['Deploy.IT3'], 'true'))
                  inputs:
                    folderPath: '$(Stakeholder3.PhysicalPath)'
                    fileType: 'json'
                    targetFiles: 'appsettings.json'
                - task: PowerShell@2
                  displayName: 'Post-transform diagnostics - IT3'
                  condition: and(succeeded(), eq(variables['Deploy.IT3'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $path = Join-Path "$(Stakeholder3.PhysicalPath)" 'appsettings.json'
                      if (-not (Test-Path $path)) { Write-Host '[Diag IT3] appsettings.json missing post-transform'; exit 0 }
                      $beforePath = Join-Path $env:PIPELINE_WORKSPACE 'IT3_appsettings_before.json'
                      $mapPath    = Join-Path $env:PIPELINE_WORKSPACE 'IT3_mapped.txt'
                      if (-not (Test-Path $beforePath) -or -not (Test-Path $mapPath)) { Write-Host '[Diag IT3] Missing pre-transform artifacts'; exit 0 }
                      $before = Get-Content $beforePath -Raw
                      $after  = Get-Content $path -Raw
                      $mapped = Get-Content $mapPath
                      function Get-JsonValue($jsonText, $dotPath) { try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $null } $cur = $obj; foreach ($seg in $dotPath.Split('.')) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $null }; $cur = $cur.$match } else { return $null } } return $cur }
                      $changed = @(); $unchanged = @(); $missing = @()
                      foreach ($p in $mapped) {
                        $b = Get-JsonValue $before $p
                        $a = Get-JsonValue $after  $p
                        if ($null -eq $b -and $null -eq $a) { $missing += $p; continue }
                        if (("$b") -ne ("$a")) { $changed += [PSCustomObject]@{ Path=$p; Before="$b"; After="$a" } }
                        else { $unchanged += $p }
                      }
                      Write-Host ("[Diag IT3] Changed={0} Unchanged={1} MissingPaths={2}" -f $changed.Count,$unchanged.Count,$missing.Count)
                      if ($changed.Count -gt 0) { $changed | Format-Table -AutoSize | Out-String -Width 200 | Write-Host }
                      if ($missing.Count -gt 0) { Write-Host '[Diag IT3] Missing:'; $missing | Sort-Object | ForEach-Object { Write-Host "  - $_" } }

                # IT4 – diagnostics: show available env vars and mapped names
                - task: PowerShell@2
                  displayName: 'Diagnostics: env → mapped variables - IT4'
                  condition: and(succeeded(), eq(variables['Deploy.IT4'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "[Diag IT4] Scanning Env: for prefixes SIT_IT4_API. and SIT_IT4_API_"
                      $found = @()
                      $remap = @{}
                      $appPath = Join-Path "$(Stakeholder4.PhysicalPath)" 'appsettings.json'
                      $jsonText = if (Test-Path $appPath) { Get-Content $appPath -Raw } else { $null }
                      foreach ($p in @('SIT_IT4_API.', 'SIT_IT4_API_')) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $mapped = $suffix -replace '__','.'
                            $hits = @(); if ($mapped -notmatch '\\.' -and $jsonText) { $hits = Find-LeafPaths $jsonText $mapped; if ($hits.Count -eq 1) { $mapped = $hits[0] } }
                            $mapType = if ($suffix -match '__' -or $mapped -match '\\.') { 'ExactPath' } elseif ($hits.Count -eq 1) { 'AutoLeafUnique' } elseif ($hits.Count -gt 1) { 'Ambiguous' } else { 'NoMatch' }
                            $masked = if ($_.Value.Length -gt 4) { ($_.Value.Substring(0,2) + '***' + $_.Value.Substring($_.Value.Length-2)) } else { '***' }
                            $found += [PSCustomObject]@{ EnvName = $_.Name; Mapped = $mapped; MapType=$mapType; Hits=$hits.Count; ValueSample = $masked }
                          }
                      }
                      Write-Host ("[Diag IT4] VarsFound={0}" -f $found.Count)
                      $found | Sort-Object MapType, Mapped | Format-Table EnvName,MapType,Hits,Mapped,ValueSample -AutoSize | Out-String -Width 200 | Write-Host
                      $amb = @($found | Where-Object { $_.MapType -eq 'Ambiguous' })
                      $miss = @($found | Where-Object { $_.MapType -eq 'NoMatch' })
                      $auto = @($found | Where-Object { $_.MapType -eq 'AutoLeafUnique' })
                      $exact = @($found | Where-Object { $_.MapType -eq 'ExactPath' })
                      Write-Host ("[Diag IT4] Summary: Exact={0} Auto={1} Ambiguous={2} NoMatch={3}" -f $exact.Count,$auto.Count,$amb.Count,$miss.Count)
                      if ($amb.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT4] Ambiguous leaf names:"; $amb | ForEach-Object { Write-Host ("  - {0} → {1} (hits={2})" -f $_.EnvName,$_.Mapped,$_.Hits) } }
                      if ($miss.Count -gt 0) { Write-Host "##vso[task.logissue type=warning][Diag IT4] NoMatch leaf names:"; $miss | ForEach-Object { Write-Host ("  - {0} (leaf='{1}')" -f $_.EnvName, ($_.EnvName -replace '^SIT_IT4_API[._]','')) } }
                # IT4 – prepare variables without prefix and run File Transform
                - task: PowerShell@2
                  displayName: 'Prepare variables for transform - IT4'
                  condition: and(succeeded(), eq(variables['Deploy.IT4'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefixes = @('SIT_IT4_API.', 'SIT_IT4_API_')
                      $remap = @{}
                      foreach ($p in $prefixes) {
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p.Length)
                            $name = $suffix -replace '__','.'
                            if ($name -notmatch '\\.' -and $remap.ContainsKey($name.ToUpper())) { $name = $remap[$name.ToUpper()] } elseif ($name -notmatch '\\.' -and $jsonText) { $hits = Find-LeafPaths $jsonText $name; if ($hits.Count -eq 1) { $name = $hits[0] } }
                            if ($jsonText -and $name -match '\\.') { $name = Normalize-PathAgainstJson $jsonText $name }
                            Write-Host "##vso[task.setvariable variable=$name]$($_.Value)"
                          }
                      }
                      $appPath = Join-Path "$(Stakeholder4.PhysicalPath)" 'appsettings.json'
                      if (Test-Path $appPath) {
                        $before = Get-Content $appPath -Raw
                        $before | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT4_appsettings_before.json') -Encoding UTF8 -Force
                        $mapped = @()
                        foreach ($pfx in $prefixes) {
                          Get-ChildItem Env: |
                            Where-Object { $_.Name -like "$pfx*" -and $_.Value -and $_.Value.Trim() -ne '' } |
                            ForEach-Object {
                              $suf = $_.Name.Substring($pfx.Length)
                              $n = $suf -replace '__','.'
                              if ($n -notmatch '\\.' -and $remap.ContainsKey($n.ToUpper())) { $n = $remap[$n.ToUpper()] }
                              $mapped += $n
                            }
                        }
                        $mapped | Sort-Object -Unique | Out-File -FilePath (Join-Path $env:PIPELINE_WORKSPACE 'IT4_mapped.txt') -Encoding UTF8 -Force
                        function Test-JsonPath($jsonText, $dotPath) { try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $false } $cur = $obj; foreach ($seg in $dotPath.Split('.')) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $false }; $cur = $cur.$match } else { return $false } } return $true }
                        $exists = @(); $notExists = @(); foreach ($mp in ($mapped | Sort-Object -Unique)) { if (Test-JsonPath $before $mp) { $exists += $mp } else { $notExists += $mp } }
                        Write-Host ("[Diag IT4] Paths existing pre-transform: {0}" -f $exists.Count)
                        if ($notExists.Count -gt 0) { Write-Host '[Diag IT4] Paths NOT found pre-transform:'; $notExists | ForEach-Object { Write-Host "  - $_" } }
                      } else { Write-Host '[Diag IT4] appsettings.json not found for pre-transform capture' }
                - task: FileTransform@1
                  displayName: 'JSON variable substitution - IT4'
                  condition: and(succeeded(), eq(variables['Deploy.IT4'], 'true'))
                  inputs:
                    folderPath: '$(Stakeholder4.PhysicalPath)'
                    fileType: 'json'
                    targetFiles: 'appsettings.json'
                - task: PowerShell@2
                  displayName: 'Post-transform diagnostics - IT4'
                  condition: and(succeeded(), eq(variables['Deploy.IT4'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $path = Join-Path "$(Stakeholder4.PhysicalPath)" 'appsettings.json'
                      if (-not (Test-Path $path)) { Write-Host '[Diag IT4] appsettings.json missing post-transform'; exit 0 }
                      $beforePath = Join-Path $env:PIPELINE_WORKSPACE 'IT4_appsettings_before.json'
                      $mapPath    = Join-Path $env:PIPELINE_WORKSPACE 'IT4_mapped.txt'
                      if (-not (Test-Path $beforePath) -or -not (Test-Path $mapPath)) { Write-Host '[Diag IT4] Missing pre-transform artifacts'; exit 0 }
                      $before = Get-Content $beforePath -Raw
                      $after  = Get-Content $path -Raw
                      $mapped = Get-Content $mapPath
                      function Get-JsonValue($jsonText, $dotPath) { try { $obj = $jsonText | ConvertFrom-Json -ErrorAction Stop } catch { return $null } $cur = $obj; foreach ($seg in $dotPath.Split('.')) { if ($cur -is [pscustomobject]) { $names = $cur.PSObject.Properties.Name; $match = $names | Where-Object { $_ -ieq $seg } | Select-Object -First 1; if (-not $match) { return $null }; $cur = $cur.$match } else { return $null } } return $cur }
                      $changed = @(); $unchanged = @(); $missing = @()
                      foreach ($p in $mapped) {
                        $b = Get-JsonValue $before $p
                        $a = Get-JsonValue $after  $p
                        if ($null -eq $b -and $null -eq $a) { $missing += $p; continue }
                        if (("$b") -ne ("$a")) { $changed += [PSCustomObject]@{ Path=$p; Before="$b"; After="$a" } }
                        else { $unchanged += $p }
                      }
                      Write-Host ("[Diag IT4] Changed={0} Unchanged={1} MissingPaths={2}" -f $changed.Count,$unchanged.Count,$missing.Count)
                      if ($changed.Count -gt 0) { $changed | Format-Table -AutoSize | Out-String -Width 200 | Write-Host }
                      if ($missing.Count -gt 0) { Write-Host '[Diag IT4] Missing:'; $missing | Sort-Object | ForEach-Object { Write-Host "  - $_" } }

  - stage: Permissions
    displayName: 'Set Permissions'
    dependsOn: InjectConfiguration
    condition: succeeded()
    jobs:
      - deployment: Set_ACLs
        displayName: 'Grant IIS permissions'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Set folder ACLs'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $paths = @()
                      if ("$(Deploy.IT1)" -eq "true") { $paths += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.IT2)" -eq "true") { $paths += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.IT3)" -eq "true") { $paths += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.IT4)" -eq "true") { $paths += "$(Stakeholder4.PhysicalPath)" }
                      foreach ($p in $paths) { $acl = Get-Acl $p; $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS","FullControl","ContainerInherit,ObjectInherit","None","Allow"); $acl.SetAccessRule($rule); Set-Acl $p $acl }

  - stage: RestartServices
    displayName: 'Restart Websites'
    dependsOn: Permissions
    condition: succeeded()
    jobs:
      - deployment: Stop_Sites
        displayName: 'Stop sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Stop websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { Stop-Website -Name $s.Name -ErrorAction Stop } catch {}
                          try { Stop-WebAppPool -Name $s.AppPool -ErrorAction Stop } catch {}
                        } else {
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" stop site /site.name:$($s.Name) 2>$null } catch {}
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" stop apppool /apppool.name:$($s.AppPool) 2>$null } catch {}
                        }
                      }
      - deployment: Start_Sites
        displayName: 'Start sites and app pools'
        dependsOn: Stop_Sites
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Start websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Port="$(Stakeholder1.Port)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Port="$(Stakeholder2.Port)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Port="$(Stakeholder3.Port)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Port="$(Stakeholder4.Port)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { if ((Get-WebAppPoolState -Name $s.AppPool -ErrorAction SilentlyContinue).Value -ne 'Started') { Start-WebAppPool -Name $s.AppPool -ErrorAction Stop } } catch {}
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) { if ($site.state -ne 'Started') { try { Start-Website -Name $s.Name -ErrorAction Stop } catch {} } }
                        } else {
                          try { if ((& "C:\\Windows\\System32\\inetsrv\\appcmd.exe" list apppool "$($s.AppPool)" /text:state 2>$null) -ne "Started") { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" start apppool /apppool.name:$($s.AppPool) 2>$null } } catch {}
                          try { if ((& "C:\\Windows\\System32\\inetsrv\\appcmd.exe" list site "$($s.Name)" /text:state 2>$null) -ne "Started") { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" start site /site.name:$($s.Name) 2>$null } } catch {}
                        }
                      }

