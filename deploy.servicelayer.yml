pool:
  name: ccoe-nprod-windows-mdp-01

trigger: none

name: $(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

parameters:
  - name: DeployIT1
    displayName: 'Deploy IT1.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT2
    displayName: 'Deploy IT2.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT3
    displayName: 'Deploy IT3.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT4
    displayName: 'Deploy IT4.API.MasterData.com'
    type: boolean
    default: true

variables:
  BuildNumber: '$(Build.BuildNumber)'
  BranchName: '$(Build.SourceBranchName)'
  BuildVersion: '$(Build.BuildId)'

  DeploymentBasePath: 'D:\\Deployments\\ServiceLayer'
  BackupBasePath: 'D:\\Backups\\ServiceLayer'

  Deploy.IT1: ${{ parameters.DeployIT1 }}
  Deploy.IT2: ${{ parameters.DeployIT2 }}
  Deploy.IT3: ${{ parameters.DeployIT3 }}
  Deploy.IT4: ${{ parameters.DeployIT4 }}

  SelectedSites: ''

  # IIS site/app definitions for ServiceLayer WebAPI
  Stakeholder1.Name: 'IT1.API.MasterData.com'
  Stakeholder1.Port: '8191'
  Stakeholder1.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT1.API.MasterData.com'
  Stakeholder1.AppPoolName: 'IT1_API_MD_AppPool'

  Stakeholder2.Name: 'IT2.API.MasterData.com'
  Stakeholder2.Port: '8192'
  Stakeholder2.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT2.API.MasterData.com'
  Stakeholder2.AppPoolName: 'IT2_API_MD_AppPool'

  Stakeholder3.Name: 'IT3.API.MasterData.com'
  Stakeholder3.Port: '8193'
  Stakeholder3.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT3.API.MasterData.com'
  Stakeholder3.AppPoolName: 'IT3_API_MD_AppPool'

  Stakeholder4.Name: 'IT4.API.MasterData.com'
  Stakeholder4.Port: '8194'
  Stakeholder4.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT4.API.MasterData.com'
  Stakeholder4.AppPoolName: 'IT4_API_MD_AppPool'

resources:
  pipelines:
   - pipeline: 'MasterData.ServiceLayer'
     project: 'MasterData'
     source: 'MasterData.ServiceLayer'
     branch: 'MDVersionUpgrade/Lonestar'

stages:
  - stage: Initialize
    displayName: 'Initialize and Select Targets'
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Initialize_Env
        displayName: 'Initialize'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: PowerShell@2
                  displayName: 'Build Information'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Branch: $(BranchName)"
                      Write-Host "Build: $(BuildNumber)"
                      Write-Host "Version: $(BuildVersion)"
                      Write-Host "IT1: $(Deploy.IT1) | IT2: $(Deploy.IT2) | IT3: $(Deploy.IT3) | IT4: $(Deploy.IT4)"
                - task: PowerShell@2
                  displayName: 'Set SelectedSites variable'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $selectedSites = @()
                      if ("$(Deploy.IT1)" -eq "true") { $selectedSites += "IT1.API.MasterData.com" }
                      if ("$(Deploy.IT2)" -eq "true") { $selectedSites += "IT2.API.MasterData.com" }
                      if ("$(Deploy.IT3)" -eq "true") { $selectedSites += "IT3.API.MasterData.com" }
                      if ("$(Deploy.IT4)" -eq "true") { $selectedSites += "IT4.API.MasterData.com" }
                      $sitesList = $selectedSites -join " "
                      Write-Host "##vso[task.setvariable variable=SelectedSites]$sitesList"
                      $date = Get-Date -Format "yyyyMMdd"
                      $definitionName = $env:BUILD_DEFINITIONNAME
                      $branchName = $env:BUILD_SOURCEBRANCHNAME
                      if (-not $definitionName -or $definitionName.Trim() -eq '') { $definitionName = 'Build' }
                      if (-not $branchName -or $branchName.Trim() -eq '') { $branchName = 'UnknownBranch' }
                      $newName = "${definitionName}_${branchName}_$date_Sites[$sitesList]"
                      Write-Host "##vso[build.updatebuildnumber]$newName"

  - stage: AcquireArtifacts
    displayName: 'Acquire Artifacts'
    dependsOn: Initialize
    condition: succeeded()
    jobs:
      - deployment: Acquire
        displayName: 'Download and Prepare Artifacts'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - download: 'MasterData.ServiceLayer'
                  displayName: 'Download artifacts'
                  artifact: 'webapi-drop'
                - task: PowerShell@2
                  displayName: 'Create required directories'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $directories = @()
                      if ("$(Deploy.IT1)" -eq "true") { $directories += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.IT2)" -eq "true") { $directories += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.IT3)" -eq "true") { $directories += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.IT4)" -eq "true") { $directories += "$(Stakeholder4.PhysicalPath)" }
                      $directories += "$(DeploymentBasePath)"
                      foreach ($dir in $directories) { if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null } }
                - task: ExtractFiles@1
                  displayName: 'Extract artifacts'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/MasterData.ServiceLayer/webapi-drop/*.zip'
                    destinationFolder: '$(DeploymentBasePath)'
                    cleanDestinationFolder: true
                    overwriteExistingFiles: true

  - stage: Backup
    displayName: 'Backup Current Deployments'
    dependsOn: AcquireArtifacts
    condition: succeeded()
    jobs:
      - deployment: Backup_Sites
        displayName: 'Backup selected sites'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Backup active content'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      if (-not (Test-Path "$(BackupBasePath)")) { New-Item -ItemType Directory -Path "$(BackupBasePath)" -Force | Out-Null }
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -eq "true") {
                          $buildId = "$(BuildVersion)"
                          $branch = "$(BranchName)"
                          $branchSafe = ($branch -replace "[^A-Za-z0-9._-]", "_")
                          $namePart = "$($s.Name)_$branchSafe_$buildId_$timestamp"
                          if ($namePart.Length -gt 150) { $namePart = $namePart.Substring(0,150) }
                          $backupPath = Join-Path "$(BackupBasePath)" $namePart
                          if (Test-Path $s.Path) {
                            New-Item -ItemType Directory -Path $backupPath -Force | Out-Null
                            Copy-Item -Path "$($s.Path)\*" -Destination $backupPath -Recurse -Force
                          }
                        }
                      }

  - stage: ConfigureIIS
    displayName: 'Configure IIS'
    dependsOn: Backup
    condition: succeeded()
    jobs:
      - deployment: Configure_IIS
        displayName: 'Ensure sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Ensure IIS configuration'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $useAppCmd = $false
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $useAppCmd = $true }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Port="$(Stakeholder1.Port)"; Path="$(Stakeholder1.PhysicalPath)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Port="$(Stakeholder2.Port)"; Path="$(Stakeholder2.PhysicalPath)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Port="$(Stakeholder3.Port)"; Path="$(Stakeholder3.PhysicalPath)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Port="$(Stakeholder4.Port)"; Path="$(Stakeholder4.PhysicalPath)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($useAppCmd) {
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" add apppool /name:$($s.AppPool) /managedRuntimeVersion:"" /managedPipelineMode:Integrated } catch {}
                          try {
                            & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" add site /name:$($s.Name) /physicalPath:$($s.Path) /bindings:http/*:$($s.Port):
                            & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" set app "$($s.Name)/" /applicationPool:$($s.AppPool)
                          } catch {}
                        } else {
                          if (-not (Test-Path "IIS:\\AppPools\\$($s.AppPool)")) { New-WebAppPool -Name $s.AppPool | Out-Null }
                          # Kestrel-hosted ASP.NET Core does not require .NET CLR in app pool
                          Set-ItemProperty "IIS:\\AppPools\\$($s.AppPool)" -Name managedRuntimeVersion -Value ""
                          Set-ItemProperty "IIS:\\AppPools\\$($s.AppPool)" -Name managedPipelineMode -Value "Integrated"
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) {
                            Set-ItemProperty "IIS:\\Sites\\$($s.Name)" -Name applicationPool -Value $s.AppPool
                            Set-ItemProperty "IIS:\\Sites\\$($s.Name)" -Name physicalPath -Value $s.Path
                            $desired = "*:$($s.Port):"
                            $httpBindings = Get-WebBinding -Name $s.Name -Protocol "http" -ErrorAction SilentlyContinue
                            $matching = @(); if ($httpBindings) { $matching = $httpBindings | Where-Object { $_.bindingInformation -eq $desired } }
                            if (-not $matching -or $matching.Count -eq 0) { New-WebBinding -Name $s.Name -Protocol "http" -Port $s.Port -IPAddress "*" -HostHeader "" }
                          } else {
                            New-Website -Name $s.Name -PhysicalPath $s.Path -ApplicationPool $s.AppPool -Port $s.Port | Out-Null
                          }
                        }
                      }

  - stage: DeployFiles
    displayName: 'Deploy Files'
    dependsOn: ConfigureIIS
    condition: succeeded()
    jobs:
      - deployment: Deploy_Content
        displayName: 'Copy application files'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Copy files to sites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if (Test-Path $s.Dest) { Get-ChildItem -Path $s.Dest -Exclude "App_Data" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
                        Copy-Item -Path "$($s.Source)\*" -Destination $s.Dest -Recurse -Force
                      }

  - stage: InjectConfiguration
    displayName: 'Inject appsettings.json Configuration'
    dependsOn: DeployFiles
    condition: succeeded()
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Inject_Config
        displayName: 'Update appsettings.json from variable groups'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Inject configuration into appsettings.json'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"; VarGroup="SIT_IT1_API"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"; VarGroup="SIT_IT2_API"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"; VarGroup="SIT_IT3_API"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"; VarGroup="SIT_IT4_API"}
                      )
                      function Get-SITVariables { param($varGroupName)
                        $siteVariables = @{}
                        $p1 = "$varGroupName."
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p1*" -and $_.Value -and $_.Value.Trim() -ne "" } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p1.Length)
                            $normalized = $suffix
                            if ($normalized -notmatch ':') {
                              if ($normalized -match '__') { $normalized = $normalized -replace '__', ':' }
                            }
                            if ($normalized -notmatch ':') {
                              if ($normalized -match '_') { $parts = $normalized -split '_', 2; if ($parts.Length -eq 2) { $normalized = $parts[0] + ':' + $parts[1] } }
                            }
                            $siteVariables[$normalized] = $_.Value
                          }
                        $p2 = "$varGroupName" + "_"
                        Get-ChildItem Env: |
                          Where-Object { $_.Name -like "$p2*" -and $_.Value -and $_.Value.Trim() -ne "" } |
                          ForEach-Object {
                            $suffix = $_.Name.Substring($p2.Length)
                            $normalized = $suffix
                            if ($normalized -notmatch ':') {
                              if ($normalized -match '__') { $normalized = $normalized -replace '__', ':' }
                            }
                            if ($normalized -notmatch ':') {
                              if ($normalized -match '_') { $parts = $normalized -split '_', 2; if ($parts.Length -eq 2) { $normalized = $parts[0] + ':' + $parts[1] } }
                            }
                            $siteVariables[$normalized] = $_.Value
                          }
                        return $siteVariables }
                      function Set-JsonValue { param([hashtable]$jsonObj, [string]$path, [string]$value)
                        $segments = $path -split ':'
                        $current = $jsonObj
                        for ($i = 0; $i -lt $segments.Length; $i++) {
                          $key = $segments[$i]
                          $actualKey = ($current.Keys | Where-Object { $_ -ieq $key } | Select-Object -First 1)
                          if (-not $actualKey) { return $false } # do not create missing nodes
                          if ($i -eq $segments.Length - 1) {
                            $current[$actualKey] = $value
                            return $true
                          } else {
                            if ($current[$actualKey] -is [hashtable]) {
                              $current = $current[$actualKey]
                            } else {
                              return $false
                            }
                          }
                        }
                        return $false
                      }
                      function ConvertTo-Hashtable { param($obj)
                        if ($null -eq $obj) { return $null }
                        if ($obj -is [System.Collections.IDictionary]) {
                          $h = @{}
                          foreach ($k in $obj.Keys) { $h[$k] = ConvertTo-Hashtable $obj[$k] }
                          return $h
                        } elseif ($obj -is [System.Collections.IEnumerable] -and -not ($obj -is [string])) {
                          $list = @()
                          foreach ($i in $obj) { $list += ,(ConvertTo-Hashtable $i) }
                          return $list
                        } elseif ($obj -is [pscustomobject]) {
                          $h = @{}
                          $obj.PSObject.Properties | ForEach-Object { $h[$_.Name] = ConvertTo-Hashtable $_.Value }
                          return $h
                        } else { return $obj }
                      }
                      # Simplified parsing: appsettings.json is strict JSON, no comment handling needed
                      function Escape-JsonString { param([string]$v)
                        if ($null -eq $v) { return '' }
                        return ($v -replace '\\','\\\\' -replace '"','\\"')
                      }
                      function Replace-JsonLeafValueInText {
                        param(
                          [string]$jsonText,
                          [string]$leafKey,
                          [string]$newValue
                        )
                        $escaped = Escape-JsonString $newValue
                        $pattern1 = '(?mi)("' + [Regex]::Escape($leafKey) + '"\s*:\s*)"[^"]*"'
                        $replacement = '$1"' + $escaped + '"'
                        $newText = [Regex]::Replace($jsonText, $pattern1, $replacement, 1)
                        if (-not ($newText -eq $jsonText)) { return @{ Text = $newText; Changed = $true } }
                        $pattern2 = '(?mi)("' + [Regex]::Escape($leafKey) + '"\s*:\s*)("[^"]*"|\d+|true|false|null)'
                        $newText2 = [Regex]::Replace($jsonText, $pattern2, $replacement, 1)
                        $changed2 = -not ($newText2 -eq $jsonText)
                        return @{ Text = $newText2; Changed = $changed2 }
                      }
                      function Process-AppSettings { param($rootPath, $variables)
                        $appSettingsPath = Join-Path $rootPath "appsettings.json"
                        if (-not (Test-Path $appSettingsPath)) { Write-Host "[InjectConfig] Missing appsettings.json at $appSettingsPath"; return @{ Updated = 0; Skipped = 0; Errors = 1 } }
                        try {
                          $text = Get-Content $appSettingsPath -Raw -ErrorAction Stop
                          $updated = 0; $skipped = 0
                          foreach ($entry in $variables.GetEnumerator()) {
                            if ([string]::IsNullOrWhiteSpace($entry.Value)) { $skipped++; continue }
                            $leaf = ($entry.Key -split ':')[-1]
                            $res = Replace-JsonLeafValueInText -jsonText $text -leafKey $leaf -newValue $entry.Value
                            if ($res.Changed) { $text = $res.Text; $updated++; Write-Host "[InjectConfig] UpdatedKey=$leaf" } else { $skipped++; Write-Host "[InjectConfig] SkippedKey=$leaf (not found)" }
                          }
                          $backupPath = "$appSettingsPath.backup.$(Get-Date -Format 'yyyyMMdd_HHmmss')"; Copy-Item $appSettingsPath $backupPath -Force
                          try { $fi = Get-Item -LiteralPath $appSettingsPath -ErrorAction Stop; if ($fi.Attributes -band [IO.FileAttributes]::ReadOnly) { Attrib -R $appSettingsPath } } catch {}
                          $text | Out-File -FilePath $appSettingsPath -Encoding UTF8 -Force
                          return @{ Updated = $updated; Skipped = $skipped; Errors = 0 }
                        } catch {
                          Write-Host ("[InjectConfig] Text replacement failed at {0}: {1}" -f $appSettingsPath, $_.Exception.Message)
                          return @{ Updated = 0; Skipped = 0; Errors = 1 }
                        }
                      }
                      $totalUpdated = 0; $totalSkipped = 0; $processed = 0
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        $vars = Get-SITVariables $s.VarGroup
                        Write-Host "[InjectConfig] Group=$($s.VarGroup) Site=$($s.Name) VarsFound=$($vars.Count)"
                        if ($vars.Count -eq 0) { Write-Host "[InjectConfig] No variables found for $($s.VarGroup); skipping $($s.Name)"; continue }
                        $res = Process-AppSettings $s.Path $vars
                        Write-Host "[InjectConfig] Updated=$($res.Updated) Skipped=$($res.Skipped) Errors=$($res.Errors) Path=$($s.Path)"
                        $totalUpdated += $res.Updated; $totalSkipped += $res.Skipped; $processed++
                      }
                      Write-Host "[InjectConfig] SitesProcessed=$processed TotalUpdated=$totalUpdated TotalSkipped=$totalSkipped"

  - stage: Permissions
    displayName: 'Set Permissions'
    dependsOn: InjectConfiguration
    condition: succeeded()
    jobs:
      - deployment: Set_ACLs
        displayName: 'Grant IIS permissions'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Set folder ACLs'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $paths = @()
                      if ("$(Deploy.IT1)" -eq "true") { $paths += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.IT2)" -eq "true") { $paths += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.IT3)" -eq "true") { $paths += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.IT4)" -eq "true") { $paths += "$(Stakeholder4.PhysicalPath)" }
                      foreach ($p in $paths) { $acl = Get-Acl $p; $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS","FullControl","ContainerInherit,ObjectInherit","None","Allow"); $acl.SetAccessRule($rule); Set-Acl $p $acl }

  - stage: RestartServices
    displayName: 'Restart Websites'
    dependsOn: Permissions
    condition: succeeded()
    jobs:
      - deployment: Stop_Sites
        displayName: 'Stop sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Stop websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { Stop-Website -Name $s.Name -ErrorAction Stop } catch {}
                          try { Stop-WebAppPool -Name $s.AppPool -ErrorAction Stop } catch {}
                        } else {
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" stop site /site.name:$($s.Name) 2>$null } catch {}
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" stop apppool /apppool.name:$($s.AppPool) 2>$null } catch {}
                        }
                      }
      - deployment: Start_Sites
        displayName: 'Start sites and app pools'
        dependsOn: Stop_Sites
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Start websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Port="$(Stakeholder1.Port)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Port="$(Stakeholder2.Port)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Port="$(Stakeholder3.Port)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Port="$(Stakeholder4.Port)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { if ((Get-WebAppPoolState -Name $s.AppPool -ErrorAction SilentlyContinue).Value -ne 'Started') { Start-WebAppPool -Name $s.AppPool -ErrorAction Stop } } catch {}
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) { if ($site.state -ne 'Started') { try { Start-Website -Name $s.Name -ErrorAction Stop } catch {} } }
                        } else {
                          try { if ((& "C:\\Windows\\System32\\inetsrv\\appcmd.exe" list apppool "$($s.AppPool)" /text:state 2>$null) -ne "Started") { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" start apppool /apppool.name:$($s.AppPool) 2>$null } } catch {}
                          try { if ((& "C:\\Windows\\System32\\inetsrv\\appcmd.exe" list site "$($s.Name)" /text:state 2>$null) -ne "Started") { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" start site /site.name:$($s.Name) 2>$null } } catch {}
                        }
                      }

