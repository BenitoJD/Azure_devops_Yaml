pool:
  name: ccoe-nprod-windows-mdp-01

trigger: none

name: $(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

parameters:
  - name: DeployIT1
    displayName: 'Deploy IT1.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT2
    displayName: 'Deploy IT2.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT3
    displayName: 'Deploy IT3.API.MasterData.com'
    type: boolean
    default: true
  - name: DeployIT4
    displayName: 'Deploy IT4.API.MasterData.com'
    type: boolean
    default: true

variables:
  BuildNumber: '$(Build.BuildNumber)'
  BranchName: '$(Build.SourceBranchName)'
  BuildVersion: '$(Build.BuildId)'

  DeploymentBasePath: 'D:\\Deployments\\ServiceLayer'
  BackupBasePath: 'D:\\Backups\\ServiceLayer'

  Deploy.IT1: ${{ parameters.DeployIT1 }}
  Deploy.IT2: ${{ parameters.DeployIT2 }}
  Deploy.IT3: ${{ parameters.DeployIT3 }}
  Deploy.IT4: ${{ parameters.DeployIT4 }}

  SelectedSites: ''

  # IIS site/app definitions for ServiceLayer WebAPI
  Stakeholder1.Name: 'IT1.API.MasterData.com'
  Stakeholder1.Port: '8191'
  Stakeholder1.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT1.API.MasterData.com'
  Stakeholder1.AppPoolName: 'IT1_API_MD_AppPool'

  Stakeholder2.Name: 'IT2.API.MasterData.com'
  Stakeholder2.Port: '8192'
  Stakeholder2.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT2.API.MasterData.com'
  Stakeholder2.AppPoolName: 'IT2_API_MD_AppPool'

  Stakeholder3.Name: 'IT3.API.MasterData.com'
  Stakeholder3.Port: '8193'
  Stakeholder3.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT3.API.MasterData.com'
  Stakeholder3.AppPoolName: 'IT3_API_MD_AppPool'

  Stakeholder4.Name: 'IT4.API.MasterData.com'
  Stakeholder4.Port: '8194'
  Stakeholder4.PhysicalPath: 'D:\\inetpub\\wwwroot\\IT4.API.MasterData.com'
  Stakeholder4.AppPoolName: 'IT4_API_MD_AppPool'

resources:
  pipelines:
   - pipeline: 'MasterData.ServiceLayer'
     project: 'MasterData'
     source: 'MasterData.ServiceLayer'
     branch: 'MDVersionUpgrade/Lonestar'

stages:
  - stage: Initialize
    displayName: 'Initialize and Select Targets'
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Initialize_Env
        displayName: 'Initialize'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: PowerShell@2
                  displayName: 'Build Information'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Branch: $(BranchName)"
                      Write-Host "Build: $(BuildNumber)"
                      Write-Host "Version: $(BuildVersion)"
                      Write-Host "IT1: $(Deploy.IT1) | IT2: $(Deploy.IT2) | IT3: $(Deploy.IT3) | IT4: $(Deploy.IT4)"
                - task: PowerShell@2
                  displayName: 'Set SelectedSites variable'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $selectedSites = @()
                      if ("$(Deploy.IT1)" -eq "true") { $selectedSites += "IT1.API.MasterData.com" }
                      if ("$(Deploy.IT2)" -eq "true") { $selectedSites += "IT2.API.MasterData.com" }
                      if ("$(Deploy.IT3)" -eq "true") { $selectedSites += "IT3.API.MasterData.com" }
                      if ("$(Deploy.IT4)" -eq "true") { $selectedSites += "IT4.API.MasterData.com" }
                      $sitesList = $selectedSites -join " "
                      Write-Host "##vso[task.setvariable variable=SelectedSites]$sitesList"
                      $date = Get-Date -Format "yyyyMMdd"
                      $definitionName = $env:BUILD_DEFINITIONNAME
                      $branchName = $env:BUILD_SOURCEBRANCHNAME
                      if (-not $definitionName -or $definitionName.Trim() -eq '') { $definitionName = 'Build' }
                      if (-not $branchName -or $branchName.Trim() -eq '') { $branchName = 'UnknownBranch' }
                      $newName = "${definitionName}_${branchName}_$date_Sites[$sitesList]"
                      Write-Host "##vso[build.updatebuildnumber]$newName"

  - stage: Diagnose
    displayName: 'Diagnose environment variables'
    dependsOn: Initialize
    condition: succeeded()
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Diagnose_Env
        displayName: 'Dump env and check variable'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: PowerShell@2
                  displayName: 'Dump environment variables'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Loaded variable groups: SIT_IT1_API, SIT_IT2_API, SIT_IT3_API, SIT_IT4_API"
                      Write-Host "Agent: $env:AGENT_NAME | Machine: $env:COMPUTERNAME | OS: $env:OS"
                      Write-Host "Build: $env:BUILD_BUILDNUMBER | Definition: $env:BUILD_DEFINITIONNAME | Branch: $env:BUILD_SOURCEBRANCHNAME"
                      Write-Host "--- BEGIN ENV ---"
                      Get-ChildItem Env: | Sort-Object Name | ForEach-Object { Write-Host ("{0}={1}" -f $_.Name, $_.Value) }
                      Write-Host "--- END ENV ---"

  - stage: AcquireArtifacts
    displayName: 'Acquire Artifacts'
    dependsOn: Initialize
    condition: succeeded()
    jobs:
      - deployment: Acquire
        displayName: 'Download and Prepare Artifacts'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - download: 'MasterData.ServiceLayer'
                  displayName: 'Download artifacts'
                  artifact: 'webapi-drop'
                - task: PowerShell@2
                  displayName: 'Create required directories'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $directories = @()
                      if ("$(Deploy.IT1)" -eq "true") { $directories += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.IT2)" -eq "true") { $directories += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.IT3)" -eq "true") { $directories += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.IT4)" -eq "true") { $directories += "$(Stakeholder4.PhysicalPath)" }
                      $directories += "$(DeploymentBasePath)"
                      foreach ($dir in $directories) { if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null } }
                - task: ExtractFiles@1
                  displayName: 'Extract artifacts'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/MasterData.ServiceLayer/webapi-drop/*.zip'
                    destinationFolder: '$(DeploymentBasePath)'
                    cleanDestinationFolder: true
                    overwriteExistingFiles: true

  - stage: Backup
    displayName: 'Backup Current Deployments'
    dependsOn: AcquireArtifacts
    condition: succeeded()
    jobs:
      - deployment: Backup_Sites
        displayName: 'Backup selected sites'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Backup active content'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      if (-not (Test-Path "$(BackupBasePath)")) { New-Item -ItemType Directory -Path "$(BackupBasePath)" -Force | Out-Null }
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -eq "true") {
                          $buildId = "$(BuildVersion)"
                          $branch = "$(BranchName)"
                          $branchSafe = ($branch -replace "[^A-Za-z0-9._-]", "_")
                          $namePart = "$($s.Name)_$branchSafe_$buildId_$timestamp"
                          if ($namePart.Length -gt 150) { $namePart = $namePart.Substring(0,150) }
                          $backupPath = Join-Path "$(BackupBasePath)" $namePart
                          if (Test-Path $s.Path) {
                            New-Item -ItemType Directory -Path $backupPath -Force | Out-Null
                            Copy-Item -Path "$($s.Path)\*" -Destination $backupPath -Recurse -Force
                          }
                        }
                      }

  - stage: ConfigureIIS
    displayName: 'Configure IIS'
    dependsOn: Backup
    condition: succeeded()
    jobs:
      - deployment: Configure_IIS
        displayName: 'Ensure sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Ensure IIS configuration'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $useAppCmd = $false
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $useAppCmd = $true }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Port="$(Stakeholder1.Port)"; Path="$(Stakeholder1.PhysicalPath)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Port="$(Stakeholder2.Port)"; Path="$(Stakeholder2.PhysicalPath)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Port="$(Stakeholder3.Port)"; Path="$(Stakeholder3.PhysicalPath)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Port="$(Stakeholder4.Port)"; Path="$(Stakeholder4.PhysicalPath)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($useAppCmd) {
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" add apppool /name:$($s.AppPool) /managedRuntimeVersion:"" /managedPipelineMode:Integrated } catch {}
                          try {
                            & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" add site /name:$($s.Name) /physicalPath:$($s.Path) /bindings:http/*:$($s.Port):
                            & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" set app "$($s.Name)/" /applicationPool:$($s.AppPool)
                          } catch {}
                        } else {
                          if (-not (Test-Path "IIS:\\AppPools\\$($s.AppPool)")) { New-WebAppPool -Name $s.AppPool | Out-Null }
                          # Kestrel-hosted ASP.NET Core does not require .NET CLR in app pool
                          Set-ItemProperty "IIS:\\AppPools\\$($s.AppPool)" -Name managedRuntimeVersion -Value ""
                          Set-ItemProperty "IIS:\\AppPools\\$($s.AppPool)" -Name managedPipelineMode -Value "Integrated"
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) {
                            Set-ItemProperty "IIS:\\Sites\\$($s.Name)" -Name applicationPool -Value $s.AppPool
                            Set-ItemProperty "IIS:\\Sites\\$($s.Name)" -Name physicalPath -Value $s.Path
                            $desired = "*:$($s.Port):"
                            $httpBindings = Get-WebBinding -Name $s.Name -Protocol "http" -ErrorAction SilentlyContinue
                            $matching = @(); if ($httpBindings) { $matching = $httpBindings | Where-Object { $_.bindingInformation -eq $desired } }
                            if (-not $matching -or $matching.Count -eq 0) { New-WebBinding -Name $s.Name -Protocol "http" -Port $s.Port -IPAddress "*" -HostHeader "" }
                          } else {
                            New-Website -Name $s.Name -PhysicalPath $s.Path -ApplicationPool $s.AppPool -Port $s.Port | Out-Null
                          }
                        }
                      }

  - stage: DeployFiles
    displayName: 'Deploy Files'
    dependsOn: ConfigureIIS
    condition: succeeded()
    jobs:
      - deployment: Deploy_Content
        displayName: 'Copy application files'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Copy files to sites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if (Test-Path $s.Dest) { Get-ChildItem -Path $s.Dest -Exclude "App_Data" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
                        Copy-Item -Path "$($s.Source)\*" -Destination $s.Dest -Recurse -Force
                      }

  - stage: DiagnoseTokens
    displayName: 'Diagnose token availability before injection'
    dependsOn: DeployFiles
    condition: succeeded()
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Diagnose_Tokens_Before
        displayName: 'List tokens in appsettings.json and map to env vars'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: PowerShell@2
                  displayName: 'Scan tokens and check variable presence'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "=== DIAGNOSTIC: Variable Group Analysis ==="
                      Write-Host "Loaded variable groups: SIT_IT1_API, SIT_IT2_API, SIT_IT3_API, SIT_IT4_API"
                      Write-Host ""
                      
                      # Show all available environment variables
                      Write-Host "=== ALL AVAILABLE ENVIRONMENT VARIABLES ==="
                      $allEnvVars = Get-ChildItem Env: | Sort-Object Name
                      $relevantVars = $allEnvVars | Where-Object { 
                        $_.Name -like '*MASTERDATA*' -or 
                        $_.Name -like '*MONGO*' -or 
                        $_.Name -like '*SIT*' -or
                        $_.Name -like '*IT1*' -or
                        $_.Name -like '*IT2*' -or
                        $_.Name -like '*IT3*' -or
                        $_.Name -like '*IT4*'
                      }
                      Write-Host "Relevant variables (MASTERDATA/MONGO/SIT/IT*):"
                      if ($relevantVars.Count -eq 0) {
                        Write-Host "  (No variables found matching patterns)"
                      } else {
                        foreach ($v in $relevantVars) {
                          $val = $v.Value
                          if ($val.Length -gt 100) { $val = $val.Substring(0, 100) + "..." }
                          Write-Host ("  {0} = {1}" -f $v.Name, $val)
                        }
                      }
                      Write-Host ""
                      
                      # Collect all tokens from all files
                      $stakeholders = @(
                        @{Label='IT1'; Group='SIT_IT1_API'; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Label='IT2'; Group='SIT_IT2_API'; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Label='IT3'; Group='SIT_IT3_API'; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Label='IT4'; Group='SIT_IT4_API'; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      $allTokens = @{}
                      
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne 'true') { continue }
                        $file = Join-Path $s.Path 'appsettings.json'
                        Write-Host "=== [$($s.Label)] Checking $file (Variable Group: $($s.Group)) ==="
                        if (-not (Test-Path $file)) { 
                          Write-Host "File not found"
                          Write-Host ""
                          continue 
                        }
                        $content = Get-Content -LiteralPath $file -Raw
                        $matches = [System.Text.RegularExpressions.Regex]::Matches($content, '\$\{([^}]+)\}')
                        $tokens = @{}
                        foreach ($m in $matches) { 
                          $tokenName = $m.Groups[1].Value
                          $tokens[$tokenName] = $true
                          $allTokens[$tokenName] = $true
                        }
                        if ($tokens.Count -eq 0) { 
                          Write-Host 'No ${...} tokens found.'
                          Write-Host ""
                          continue 
                        }
                        Write-Host "Found tokens:"
                        foreach ($t in $tokens.Keys | Sort-Object) { Write-Host "  - ${$t}" }
                        Write-Host ""
                        Write-Host "Checking for matching environment variables:"
                        foreach ($t in $tokens.Keys | Sort-Object) {
                          $baseEnvKey = ($t -replace '[^A-Za-z0-9_]', '_').ToUpper()
                          $found = $false
                          
                          # Try standard transformation
                          if (Test-Path "Env:$baseEnvKey") {
                            $val = (Get-Item "Env:$baseEnvKey").Value
                            if ($val.Length -gt 80) { $val = $val.Substring(0, 80) + "..." }
                            Write-Host ("  ✓ FOUND: {0} -> Env:{1} = {2}" -f $t, $baseEnvKey, $val)
                            $found = $true
                          }
                          
                          # Try with group prefix (SIT_IT1_API_)
                          if (-not $found) {
                            $groupPrefix = ($s.Group -replace '[^A-Za-z0-9_]', '_').ToUpper() + '_'
                            $prefixedKey = $groupPrefix + $baseEnvKey
                            if (Test-Path "Env:$prefixedKey") {
                              $val = (Get-Item "Env:$prefixedKey").Value
                              if ($val.Length -gt 80) { $val = $val.Substring(0, 80) + "..." }
                              Write-Host ("  ✓ FOUND (with group prefix): {0} -> Env:{1} = {2}" -f $t, $prefixedKey, $val)
                              $found = $true
                            }
                          }
                          
                          # Try with double underscore (Azure DevOps sometimes uses this)
                          if (-not $found) {
                            $doubleUnderscoreKey = $baseEnvKey -replace '_+', '__'
                            if ($doubleUnderscoreKey -ne $baseEnvKey -and (Test-Path "Env:$doubleUnderscoreKey")) {
                              $val = (Get-Item "Env:$doubleUnderscoreKey").Value
                              if ($val.Length -gt 80) { $val = $val.Substring(0, 80) + "..." }
                              Write-Host ("  ✓ FOUND (double underscore): {0} -> Env:{1} = {2}" -f $t, $doubleUnderscoreKey, $val)
                              $found = $true
                            }
                          }
                          
                          # Try partial matches (maybe the variable name is slightly different)
                          if (-not $found) {
                            $searchPattern = $baseEnvKey -replace '_.*$', ''
                            $partialMatches = $allEnvVars | Where-Object { $_.Name -like "$searchPattern*" }
                            if ($partialMatches.Count -gt 0) {
                              Write-Host ("  ⚠ PARTIAL MATCHES for '{0}' (looking for '{1}'):" -f $t, $baseEnvKey)
                              foreach ($pm in $partialMatches | Select-Object -First 5) {
                                $val = $pm.Value
                                if ($val.Length -gt 60) { $val = $val.Substring(0, 60) + "..." }
                                Write-Host ("    - Env:{0} = {1}" -f $pm.Name, $val)
                              }
                            }
                          }
                          
                          if (-not $found) {
                            Write-Host ("  ✗ MISSING: {0} -> Expected Env:{1} (not found)" -f $t, $baseEnvKey)
                          }
                        }
                        Write-Host ""
                      }
                      
                      Write-Host "=== SUMMARY ==="
                      Write-Host "Total unique tokens found: $($allTokens.Count)"
                      Write-Host "All tokens: $($allTokens.Keys -join ', ')"
                      Write-Host ""
                      Write-Host "=== NEXT STEPS ==="
                      Write-Host "1. Check if variable groups (SIT_IT1_API, etc.) contain variables with these exact names"
                      Write-Host "2. Verify variable names in Azure DevOps match the token names (case-sensitive after transformation)"
                      Write-Host "3. Ensure variable groups are properly linked to this pipeline"

  - stage: InjectConfiguration
    displayName: 'Inject appsettings.json Configuration'
    dependsOn: DeployFiles
    condition: succeeded()
    variables:
      - group: SIT_IT1_API
      - group: SIT_IT2_API
      - group: SIT_IT3_API
      - group: SIT_IT4_API
    jobs:
      - deployment: Inject_Config
        displayName: 'Tokenize and inject appsettings.json with Replace Tokens'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Map SIT_IT1_API_* env vars to unprefixed tokens (IT1)'
                  condition: and(succeeded(), eq(variables['Deploy.IT1'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefix = 'SIT_IT1_API_'
                      Write-Host "Mapping variables with prefix '$prefix' to unprefixed names for Replace Tokens"
                      $envVars = Get-ChildItem Env: | Where-Object { $_.Name -like "$prefix*" }
                      foreach ($v in $envVars) {
                        $name = $v.Name.Substring($prefix.Length)
                        $value = $v.Value
                        Write-Host " - $($v.Name) -> $name"
                        Write-Host "##vso[task.setvariable variable=$name]$value"
                        $env:$name = $value
                      }
                - task: qetza.replacetokens.replacetokens-task.replacetokens@5
                  displayName: 'Replace tokens in appsettings.json - IT1'
                  condition: and(succeeded(), eq(variables['Deploy.IT1'], 'true'))
                  inputs:
                    rootDirectory: '$(Stakeholder1.PhysicalPath)'
                    targetFiles: 'appsettings.json'
                    encoding: 'auto'
                    writeBOM: true
                    actionOnMissing: 'keep'
                    keepToken: true
                    tokenPrefix: '${'
                    tokenSuffix: '}'

                - task: PowerShell@2
                  displayName: 'Map SIT_IT2_API_* env vars to unprefixed tokens (IT2)'
                  condition: and(succeeded(), eq(variables['Deploy.IT2'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefix = 'SIT_IT2_API_'
                      Write-Host "Mapping variables with prefix '$prefix' to unprefixed names for Replace Tokens"
                      $envVars = Get-ChildItem Env: | Where-Object { $_.Name -like "$prefix*" }
                      foreach ($v in $envVars) {
                        $name = $v.Name.Substring($prefix.Length)
                        $value = $v.Value
                        Write-Host " - $($v.Name) -> $name"
                        Write-Host "##vso[task.setvariable variable=$name]$value"
                        $env:$name = $value
                      }
                - task: qetza.replacetokens.replacetokens-task.replacetokens@5
                  displayName: 'Replace tokens in appsettings.json - IT2'
                  condition: and(succeeded(), eq(variables['Deploy.IT2'], 'true'))
                  inputs:
                    rootDirectory: '$(Stakeholder2.PhysicalPath)'
                    targetFiles: 'appsettings.json'
                    encoding: 'auto'
                    writeBOM: true
                    actionOnMissing: 'keep'
                    keepToken: true
                    tokenPrefix: '${'
                    tokenSuffix: '}'

                - task: PowerShell@2
                  displayName: 'Map SIT_IT3_API_* env vars to unprefixed tokens (IT3)'
                  condition: and(succeeded(), eq(variables['Deploy.IT3'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefix = 'SIT_IT3_API_'
                      Write-Host "Mapping variables with prefix '$prefix' to unprefixed names for Replace Tokens"
                      $envVars = Get-ChildItem Env: | Where-Object { $_.Name -like "$prefix*" }
                      foreach ($v in $envVars) {
                        $name = $v.Name.Substring($prefix.Length)
                        $value = $v.Value
                        Write-Host " - $($v.Name) -> $name"
                        Write-Host "##vso[task.setvariable variable=$name]$value"
                        $env:$name = $value
                      }
                - task: qetza.replacetokens.replacetokens-task.replacetokens@5
                  displayName: 'Replace tokens in appsettings.json - IT3'
                  condition: and(succeeded(), eq(variables['Deploy.IT3'], 'true'))
                  inputs:
                    rootDirectory: '$(Stakeholder3.PhysicalPath)'
                    targetFiles: 'appsettings.json'
                    encoding: 'auto'
                    writeBOM: true
                    actionOnMissing: 'keep'
                    keepToken: true
                    tokenPrefix: '${'
                    tokenSuffix: '}'

                - task: PowerShell@2
                  displayName: 'Map SIT_IT4_API_* env vars to unprefixed tokens (IT4)'
                  condition: and(succeeded(), eq(variables['Deploy.IT4'], 'true'))
                  inputs:
                    targetType: 'inline'
                    script: |
                      $prefix = 'SIT_IT4_API_'
                      Write-Host "Mapping variables with prefix '$prefix' to unprefixed names for Replace Tokens"
                      $envVars = Get-ChildItem Env: | Where-Object { $_.Name -like "$prefix*" }
                      foreach ($v in $envVars) {
                        $name = $v.Name.Substring($prefix.Length)
                        $value = $v.Value
                        Write-Host " - $($v.Name) -> $name"
                        Write-Host "##vso[task.setvariable variable=$name]$value"
                        $env:$name = $value
                      }
                - task: qetza.replacetokens.replacetokens-task.replacetokens@5
                  displayName: 'Replace tokens in appsettings.json - IT4'
                  condition: and(succeeded(), eq(variables['Deploy.IT4'], 'true'))
                  inputs:
                    rootDirectory: '$(Stakeholder4.PhysicalPath)'
                    targetFiles: 'appsettings.json'
                    encoding: 'auto'
                    writeBOM: true
                    actionOnMissing: 'keep'
                    keepToken: true
                    tokenPrefix: '${'
                    tokenSuffix: '}'

  - stage: DiagnosePostInject
    displayName: 'Diagnose after injection (unresolved tokens)'
    dependsOn: InjectConfiguration
    condition: succeeded()
    jobs:
      - deployment: Diagnose_Tokens_After
        displayName: 'Verify tokens are replaced in appsettings.json'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: PowerShell@2
                  displayName: 'Report unresolved tokens'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $stakeholders = @(
                        @{Label='IT1'; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.IT1)"},
                        @{Label='IT2'; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.IT2)"},
                        @{Label='IT3'; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.IT3)"},
                        @{Label='IT4'; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne 'true') { continue }
                        $file = Join-Path $s.Path 'appsettings.json'
                        Write-Host "--- [$($s.Label)] Verifying $file ---"
                        if (-not (Test-Path $file)) { Write-Host "File not found"; continue }
                        $content = Get-Content -LiteralPath $file -Raw
                        $matches = [System.Text.RegularExpressions.Regex]::Matches($content, '\$\{([^}]+)\}')
                        if ($matches.Count -eq 0) { Write-Host 'All tokens appear replaced (no ${...} found).'; continue }
                        $unresolved = @{}
                        foreach ($m in $matches) { $unresolved[$m.Groups[1].Value] = $true }
                        Write-Host 'Unresolved tokens found:'
                        foreach ($t in $unresolved.Keys | Sort-Object) { Write-Host "  - ${$t}" }
                      }

  - stage: Permissions
    displayName: 'Set Permissions'
    dependsOn: InjectConfiguration
    condition: succeeded()
    jobs:
      - deployment: Set_ACLs
        displayName: 'Grant IIS permissions'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Set folder ACLs'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $paths = @()
                      if ("$(Deploy.IT1)" -eq "true") { $paths += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.IT2)" -eq "true") { $paths += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.IT3)" -eq "true") { $paths += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.IT4)" -eq "true") { $paths += "$(Stakeholder4.PhysicalPath)" }
                      foreach ($p in $paths) { $acl = Get-Acl $p; $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS","FullControl","ContainerInherit,ObjectInherit","None","Allow"); $acl.SetAccessRule($rule); Set-Acl $p $acl }

  - stage: RestartServices
    displayName: 'Restart Websites'
    dependsOn: Permissions
    condition: succeeded()
    jobs:
      - deployment: Stop_Sites
        displayName: 'Stop sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Stop websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { Stop-Website -Name $s.Name -ErrorAction Stop } catch {}
                          try { Stop-WebAppPool -Name $s.AppPool -ErrorAction Stop } catch {}
                        } else {
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" stop site /site.name:$($s.Name) 2>$null } catch {}
                          try { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" stop apppool /apppool.name:$($s.AppPool) 2>$null } catch {}
                        }
                      }
      - deployment: Start_Sites
        displayName: 'Start sites and app pools'
        dependsOn: Stop_Sites
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Start websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Port="$(Stakeholder1.Port)"; Deploy="$(Deploy.IT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Port="$(Stakeholder2.Port)"; Deploy="$(Deploy.IT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Port="$(Stakeholder3.Port)"; Deploy="$(Deploy.IT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Port="$(Stakeholder4.Port)"; Deploy="$(Deploy.IT4)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { if ((Get-WebAppPoolState -Name $s.AppPool -ErrorAction SilentlyContinue).Value -ne 'Started') { Start-WebAppPool -Name $s.AppPool -ErrorAction Stop } } catch {}
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) { if ($site.state -ne 'Started') { try { Start-Website -Name $s.Name -ErrorAction Stop } catch {} } }
                        } else {
                          try { if ((& "C:\\Windows\\System32\\inetsrv\\appcmd.exe" list apppool "$($s.AppPool)" /text:state 2>$null) -ne "Started") { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" start apppool /apppool.name:$($s.AppPool) 2>$null } } catch {}
                          try { if ((& "C:\\Windows\\System32\\inetsrv\\appcmd.exe" list site "$($s.Name)" /text:state 2>$null) -ne "Started") { & "C:\\Windows\\System32\\inetsrv\\appcmd.exe" start site /site.name:$($s.Name) 2>$null } } catch {}
                        }
                      }

