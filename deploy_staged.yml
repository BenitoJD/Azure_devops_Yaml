pool:
  name: ccoe-nprod-windows-mdp-01

trigger:
- none

name: $(BuildDefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

parameters:
  - name: DeployFT1
    displayName: 'Deploy FT1 Website'
    type: boolean
    default: true
  - name: DeployFT2
    displayName: 'Deploy FT2 Website'
    type: boolean
    default: true
  - name: DeployFT3
    displayName: 'Deploy FT3 Website'
    type: boolean
    default: true
  - name: DeployR1
    displayName: 'Deploy R1 Website'
    type: boolean
    default: true

variables:
  BuildNumber: '$(Build.BuildNumber)'
  BranchName: '$(Build.SourceBranchName)'
  BuildVersion: '$(Build.BuildId)'

  DeploymentBasePath: 'D:\Deployments'
  BackupBasePath: 'D:\Backups'

  Deploy.FT1: ${{ parameters.DeployFT1 }}
  Deploy.FT2: ${{ parameters.DeployFT2 }}
  Deploy.FT3: ${{ parameters.DeployFT3 }}
  Deploy.R1: ${{ parameters.DeployR1 }}

  SelectedSites: ''

  Stakeholder1.Name: 'FT1'
  Stakeholder1.Port: '8091'
  Stakeholder1.PhysicalPath: 'D:\inetpub\wwwroot\FT1.Main'
  Stakeholder1.AppPoolName: 'FT1AppPool'

  Stakeholder2.Name: 'FT2'
  Stakeholder2.Port: '8092'
  Stakeholder2.PhysicalPath: 'D:\inetpub\wwwroot\FT2.Main'
  Stakeholder2.AppPoolName: 'FT2AppPool'

  Stakeholder3.Name: 'FT3'
  Stakeholder3.Port: '8093'
  Stakeholder3.PhysicalPath: 'D:\inetpub\wwwroot\FT3.Main'
  Stakeholder3.AppPoolName: 'FT3AppPool'

  Stakeholder4.Name: 'R1'
  Stakeholder4.Port: '8094'
  Stakeholder4.PhysicalPath: 'D:\inetpub\wwwroot\R1.Main'
  Stakeholder4.AppPoolName: 'R1AppPool'

resources:
  pipelines:
   - pipeline: 'MasterData.Main'
     project: 'MasterData'
     source: 'MasterData.Main'
     branch: 'MDVersionUpgrade/Lonestar'

stages:
  - stage: Initialize
    displayName: 'Initialize and Select Targets'
    variables:
      - group: SIT_FT1
      - group: SIT_FT2
      - group: SIT_FT3
      - group: SIT_R1
    jobs:
      - deployment: Initialize_Env
        displayName: 'Initialize'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none
                - task: PowerShell@2
                  displayName: 'Build Information'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Branch: $(BranchName)"
                      Write-Host "Build: $(BuildNumber)"
                      Write-Host "Version: $(BuildVersion)"
                      Write-Host "FT1: $(Deploy.FT1) | FT2: $(Deploy.FT2) | FT3: $(Deploy.FT3) | R1: $(Deploy.R1)"
                - task: PowerShell@2
                  displayName: 'Set SelectedSites variable'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $selectedSites = @()
                      if ("$(Deploy.FT1)" -eq "true") { $selectedSites += "FT1" }
                      if ("$(Deploy.FT2)" -eq "true") { $selectedSites += "FT2" }
                      if ("$(Deploy.FT3)" -eq "true") { $selectedSites += "FT3" }
                      if ("$(Deploy.R1)" -eq "true") { $selectedSites += "R1" }
                      $sitesList = $selectedSites -join " "
                      Write-Host "##vso[task.setvariable variable=SelectedSites]$sitesList"
                      $date = Get-Date -Format "yyyyMMdd"
                      $definitionName = $env:BUILD_DEFINITIONNAME
                      $branchName = $env:BUILD_SOURCEBRANCHNAME
                      if (-not $definitionName -or $definitionName.Trim() -eq '') { $definitionName = 'Build' }
                      if (-not $branchName -or $branchName.Trim() -eq '') { $branchName = 'UnknownBranch' }
                      $newName = "${definitionName}_${branchName}_$date_Sites[$sitesList]"
                      Write-Host "##vso[build.updatebuildnumber]$newName"

  - stage: AcquireArtifacts
    displayName: 'Acquire Artifacts'
    dependsOn: Initialize
    condition: succeeded()
    jobs:
      - deployment: Acquire
        displayName: 'Download and Prepare Artifacts'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - download: 'MasterData.Main'
                  displayName: 'Download artifacts'
                  artifact: 'drop'
                - task: PowerShell@2
                  displayName: 'Create required directories'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $directories = @()
                      if ("$(Deploy.FT1)" -eq "true") { $directories += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.FT2)" -eq "true") { $directories += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.FT3)" -eq "true") { $directories += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.R1)" -eq "true") { $directories += "$(Stakeholder4.PhysicalPath)" }
                      $directories += "$(DeploymentBasePath)"
                      foreach ($dir in $directories) { if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null } }
                - task: ExtractFiles@1
                  displayName: 'Extract artifacts'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/MasterData.Main/drop/*.zip'
                    destinationFolder: '$(DeploymentBasePath)'
                    cleanDestinationFolder: true
                    overwriteExistingFiles: true

  - stage: Backup
    displayName: 'Backup Current Deployments'
    dependsOn: AcquireArtifacts
    condition: succeeded()
    jobs:
      - deployment: Backup_Sites
        displayName: 'Backup selected sites'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Backup active content'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.R1)"}
                      )
                      if (-not (Test-Path "$(BackupBasePath)")) { New-Item -ItemType Directory -Path "$(BackupBasePath)" -Force | Out-Null }
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -eq "true") {
                          $backupPath = "$(BackupBasePath)\$($s.Name)_$(BranchName)_$(BuildNumber)_$timestamp"
                          if (Test-Path $s.Path) {
                            New-Item -ItemType Directory -Path $backupPath -Force | Out-Null
                            Copy-Item -Path "$($s.Path)\*" -Destination $backupPath -Recurse -Force
                          }
                        }
                      }

  - stage: ConfigureIIS
    displayName: 'Configure IIS'
    dependsOn: Backup
    condition: succeeded()
    jobs:
      - deployment: Configure_IIS
        displayName: 'Ensure sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Ensure IIS configuration'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $useAppCmd = $false
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $useAppCmd = $true }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Port="$(Stakeholder1.Port)"; Path="$(Stakeholder1.PhysicalPath)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; Port="$(Stakeholder2.Port)"; Path="$(Stakeholder2.PhysicalPath)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; Port="$(Stakeholder3.Port)"; Path="$(Stakeholder3.PhysicalPath)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; Port="$(Stakeholder4.Port)"; Path="$(Stakeholder4.PhysicalPath)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.R1)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($useAppCmd) {
                          try { & "C:\Windows\System32\inetsrv\appcmd.exe" add apppool /name:$($s.AppPool) /managedRuntimeVersion:v4.0 /managedPipelineMode:Integrated } catch {}
                          try {
                            & "C:\Windows\System32\inetsrv\appcmd.exe" add site /name:$($s.Name) /physicalPath:$($s.Path) /bindings:http/*:$($s.Port):
                            & "C:\Windows\System32\inetsrv\appcmd.exe" set app "$($s.Name)/" /applicationPool:$($s.AppPool)
                          } catch {}
                        } else {
                          if (-not (Test-Path "IIS:\AppPools\$($s.AppPool)")) { New-WebAppPool -Name $s.AppPool | Out-Null }
                          Set-ItemProperty "IIS:\AppPools\$($s.AppPool)" -Name managedRuntimeVersion -Value "v4.0"
                          Set-ItemProperty "IIS:\AppPools\$($s.AppPool)" -Name managedPipelineMode -Value "Integrated"
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) {
                            Set-ItemProperty "IIS:\Sites\$($s.Name)" -Name applicationPool -Value $s.AppPool
                            Set-ItemProperty "IIS:\Sites\$($s.Name)" -Name physicalPath -Value $s.Path
                            $desired = "*:$($s.Port):"
                            $httpBindings = Get-WebBinding -Name $s.Name -Protocol "http" -ErrorAction SilentlyContinue
                            $matching = @(); if ($httpBindings) { $matching = $httpBindings | Where-Object { $_.bindingInformation -eq $desired } }
                            if (-not $matching -or $matching.Count -eq 0) { New-WebBinding -Name $s.Name -Protocol "http" -Port $s.Port -IPAddress "*" -HostHeader "" }
                          } else {
                            New-Website -Name $s.Name -PhysicalPath $s.Path -ApplicationPool $s.AppPool -Port $s.Port | Out-Null
                          }
                        }
                      }

  - stage: DeployFiles
    displayName: 'Deploy Files'
    dependsOn: ConfigureIIS
    condition: succeeded()
    jobs:
      - deployment: Deploy_Content
        displayName: 'Copy application files'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Copy files to sites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.R1)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if (Test-Path $s.Dest) { Get-ChildItem -Path $s.Dest -Exclude "App_Data" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
                        Copy-Item -Path "$($s.Source)\*" -Destination $s.Dest -Recurse -Force
                      }

  - stage: InjectConfiguration
    displayName: 'Inject Configuration'
    dependsOn: DeployFiles
    condition: succeeded()
    variables:
      - group: SIT_FT1
      - group: SIT_FT2
      - group: SIT_FT3
      - group: SIT_R1
    jobs:
      - deployment: Inject_Config
        displayName: 'Update web.config values from variable groups'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Inject configuration into web.config'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.FT1)"; Port="$(Stakeholder1.Port)"; VarGroup="SIT_FT1"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.FT2)"; Port="$(Stakeholder2.Port)"; VarGroup="SIT_FT2"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.FT3)"; Port="$(Stakeholder3.Port)"; VarGroup="SIT_FT3"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.R1)"; Port="$(Stakeholder4.Port)"; VarGroup="SIT_R1"}
                      )
                      function Get-SITVariables { param($varGroupName)
                        $siteVariables = @{}
                        $p1 = "$varGroupName."; Get-ChildItem Env: | Where-Object { $_.Name -like "$p1*" -and $_.Value -and $_.Value.Trim() -ne "" } | ForEach-Object { $siteVariables[$_.Name.Substring($p1.Length)] = $_.Value }
                        $p2 = "$varGroupName" + "_"; Get-ChildItem Env: | Where-Object { $_.Name -like "$p2*" -and $_.Value -and $_.Value.Trim() -ne "" } | ForEach-Object { $siteVariables[$_.Name.Substring($p2.Length)] = $_.Value }
                        return $siteVariables }
                      function Process-WebConfig { param($stakeholder, $allVariables)
                        $webConfigPath = Join-Path $stakeholder.Path "web.config"
                        if (-not (Test-Path $webConfigPath)) { return @{ Updated = 0; Skipped = 0; Errors = 1 } }
                        try {
                          [xml]$webConfig = Get-Content $webConfigPath -ErrorAction Stop
                          if (-not $webConfig.configuration) { return @{ Updated = 0; Skipped = 0; Errors = 1 } }
                          $existingAppSettings = @{}; $existingConnectionStrings = @{}
                          if ($webConfig.configuration.appSettings) { $webConfig.configuration.appSettings.add | ForEach-Object { $existingAppSettings[$_.key] = $_.value } }
                          if ($webConfig.configuration.connectionStrings) { $webConfig.configuration.connectionStrings.add | ForEach-Object { $existingConnectionStrings[$_.name] = $_.connectionString } }
                          $updatedCount = 0; $skippedCount = 0
                          $keyMapping = @{ 'MDSERVICEURL'='MDServiceUrl'; 'OBDCONTEXT'='OBDContext'; 'REPORTSERVERFOLDERNAME'='ReportServerFolderName'; 'REPORTSERVERURL'='ReportServerUrl'; 'REPORTSERVERWEBSERVICEURL'='ReportServerWebServiceUrl'; 'SERVER_REPORTSERVICE_URI'='Server_ReportService_URI'; 'SITEEDITORTOOL_LOCATION'='SiteEditorTool_Location' }
                          $connectionStringKeys = @('OBDCONTEXT')
                          foreach ($variable in $allVariables.GetEnumerator()) {
                            $varName = $variable.Key; $varValue = $variable.Value; $matched = $false
                            $mappedKey = if ($keyMapping.ContainsKey($varName)) { $keyMapping[$varName] } else { $varName }
                            if ($connectionStringKeys -contains $varName) {
                              $connectionKey = ($existingConnectionStrings.Keys | Where-Object { $_ -eq $mappedKey -or $_ -ieq $varName } | Select-Object -First 1)
                              if ($connectionKey) { $node = $webConfig.configuration.connectionStrings.SelectSingleNode("add[@name='$connectionKey']"); if ($node) { $node.connectionString = $varValue; $updatedCount++; $matched = $true } }
                            }
                            if (-not $matched) {
                              $appKey = ($existingAppSettings.Keys | Where-Object { $_ -eq $mappedKey -or $_ -ieq $varName } | Select-Object -First 1)
                              if ($appKey) { $node = $webConfig.configuration.appSettings.SelectSingleNode("add[@key='$appKey']"); if ($node) { $node.value = $varValue; $updatedCount++; $matched = $true } }
                            }
                            if (-not $matched) { $skippedCount++ }
                          }
                          $backupPath = "$webConfigPath.backup.$(Get-Date -Format 'yyyyMMdd_HHmmss')"; Copy-Item $webConfigPath $backupPath -Force
                          $webConfig.Save($webConfigPath)
                          return @{ Updated = $updatedCount; Skipped = $skippedCount; Errors = 0 }
                        } catch { return @{ Updated = 0; Skipped = 0; Errors = 1 } }
                      }
                      $totalUpdated = 0; $totalSkipped = 0; $processed = 0
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        $vars = Get-SITVariables $s.VarGroup
                        if ($vars.Count -eq 0) { continue }
                        $res = Process-WebConfig $s $vars
                        $totalUpdated += $res.Updated; $totalSkipped += $res.Skipped; $processed++
                      }

  - stage: Permissions
    displayName: 'Set Permissions'
    dependsOn: InjectConfiguration
    condition: succeeded()
    jobs:
      - deployment: Set_ACLs
        displayName: 'Grant IIS permissions'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Set folder ACLs'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $paths = @()
                      if ("$(Deploy.FT1)" -eq "true") { $paths += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.FT2)" -eq "true") { $paths += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.FT3)" -eq "true") { $paths += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.R1)" -eq "true") { $paths += "$(Stakeholder4.PhysicalPath)" }
                      foreach ($p in $paths) { $acl = Get-Acl $p; $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS","FullControl","ContainerInherit,ObjectInherit","None","Allow"); $acl.SetAccessRule($rule); Set-Acl $p $acl }

  - stage: RestartServices
    displayName: 'Restart Websites'
    dependsOn: Permissions
    condition: succeeded()
    jobs:
      - deployment: Stop_Sites
        displayName: 'Stop sites and app pools'
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Stop websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.R1)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { Stop-Website -Name $s.Name -ErrorAction Stop } catch {}
                          try { Stop-WebAppPool -Name $s.AppPool -ErrorAction Stop } catch {}
                        } else {
                          try { & "C:\Windows\System32\inetsrv\appcmd.exe" stop site /site.name:$($s.Name) 2>$null } catch {}
                          try { & "C:\Windows\System32\inetsrv\appcmd.exe" stop apppool /apppool.name:$($s.AppPool) 2>$null } catch {}
                        }
                      }
      - deployment: Start_Sites
        displayName: 'Start sites and app pools'
        dependsOn: Stop_Sites
        environment:
          name: SIT
          resourceType: virtualMachine
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Start websites'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $usePowerShell = $true
                      try { Import-Module WebAdministration -ErrorAction Stop } catch { $usePowerShell = $false }
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Port="$(Stakeholder1.Port)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Port="$(Stakeholder2.Port)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Port="$(Stakeholder3.Port)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Port="$(Stakeholder4.Port)"; Deploy="$(Deploy.R1)"}
                      )
                      foreach ($s in $stakeholders) {
                        if ($s.Deploy -ne "true") { continue }
                        if ($usePowerShell) {
                          try { if ((Get-WebAppPoolState -Name $s.AppPool -ErrorAction SilentlyContinue).Value -ne 'Started') { Start-WebAppPool -Name $s.AppPool -ErrorAction Stop } } catch {}
                          $site = Get-Website -Name $s.Name -ErrorAction SilentlyContinue
                          if ($site) { if ($site.state -ne 'Started') { try { Start-Website -Name $s.Name -ErrorAction Stop } catch {} } }
                        } else {
                          try { if ((& "C:\Windows\System32\inetsrv\appcmd.exe" list apppool "$($s.AppPool)" /text:state 2>$null) -ne "Started") { & "C:\Windows\System32\inetsrv\appcmd.exe" start apppool /apppool.name:$($s.AppPool) 2>$null } } catch {}
                          try { if ((& "C:\Windows\System32\inetsrv\appcmd.exe" list site "$($s.Name)" /text:state 2>$null) -ne "Started") { & "C:\Windows\System32\inetsrv\appcmd.exe" start site /site.name:$($s.Name) 2>$null } } catch {}
                        }
                      }

