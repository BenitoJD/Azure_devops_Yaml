pool:
  name: ccoe-nprod-windows-mdp-01

trigger: none

name: DataLoad_${{ parameters.dbSlot }}_$(Date:yyyyMMdd)$(Rev:.r)

parameters:
  - name: dbSlot
    displayName: 'Database Environment / Slot'
    type: string
    default: Dev
    values:
      - Dev
      - FT1
      - FT2
      - FT3
      - QA
      - R1
      - Demo
      - SIT
      - Pre-Prod
      - Production

variables:
  - name: BuildNumber
    value: '$(Build.BuildNumber)'
  - name: BranchName
    value: '$(Build.SourceBranchName)'
  - name: BuildVersion
    value: '$(Build.BuildId)'
  - name: dbSlot
    value: ${{ parameters.dbSlot }}

  # Server catalog and paths
  - group: vg-shared-servers
  - group: vg-shared-paths

  # WinRM service account (non-prod vs prod) based on dbSlot
  - ${{ if ne(parameters.dbSlot, 'Production') }}:
      - group: NonProd-WinRM-ServiceAccount
  - ${{ if eq(parameters.dbSlot, 'Production') }}:
      - group: Prod-WinRM-ServiceAccount

  # Server selection per dbSlot (from vg-shared-servers)
  - ${{ if eq(parameters.dbSlot, 'Dev') }}:
      - name: selectedDbServers
        value: '$(Development-db-server)'
  - ${{ if eq(parameters.dbSlot, 'FT1') }}:
      - name: selectedDbServers
        value: '$(Development-db-server)'
  - ${{ if eq(parameters.dbSlot, 'FT2') }}:
      - name: selectedDbServers
        value: '$(Development-db-server)'
  - ${{ if eq(parameters.dbSlot, 'FT3') }}:
      - name: selectedDbServers
        value: '$(Development-db-server)'
  - ${{ if eq(parameters.dbSlot, 'QA') }}:
      - name: selectedDbServers
        value: '$(Development-db-server)'
  - ${{ if eq(parameters.dbSlot, 'R1') }}:
      - name: selectedDbServers
        value: '$(Development-db-server)'
  - ${{ if eq(parameters.dbSlot, 'Demo') }}:
      - name: selectedDbServers
        value: '$(Development-db-server)'
  - ${{ if eq(parameters.dbSlot, 'SIT') }}:
      - name: selectedDbServers
        value: '$(SIT-db-server)'
  - ${{ if eq(parameters.dbSlot, 'Pre-Prod') }}:
      - name: selectedDbServers
        value: '$(Pre-prod-dbPrimary-server),$(Pre-prod-dbSecondary-server)'
  - ${{ if eq(parameters.dbSlot, 'Production') }}:
      - name: selectedDbServers
        value: '$(Production-dbPrimary-Server),$(Production-dbSecondary-Server)'

  # Database configuration variable groups (per slot)
  - ${{ if eq(parameters.dbSlot, 'Dev') }}:
      - group: Development_Dataload
  - ${{ if eq(parameters.dbSlot, 'FT1') }}:
      - group: FT1_Dataload
  - ${{ if eq(parameters.dbSlot, 'FT2') }}:
      - group: FT2_Dataload
  - ${{ if eq(parameters.dbSlot, 'FT3') }}:
      - group: FT3_Dataload
  - ${{ if eq(parameters.dbSlot, 'QA') }}:
      - group: QA_Dataload
  - ${{ if eq(parameters.dbSlot, 'R1') }}:
      - group: R1_Dataload
  - ${{ if eq(parameters.dbSlot, 'Demo') }}:
      - group: Demo_Dataload
  - ${{ if eq(parameters.dbSlot, 'SIT') }}:
      - group: SIT_Dataload
  - ${{ if eq(parameters.dbSlot, 'Pre-Prod') }}:
      - group: Pre-Prod_Dataload
  - ${{ if eq(parameters.dbSlot, 'Production') }}:
      - group: Production_Dataload

resources:
  pipelines:
    - pipeline: 'MasterData.DB.DataLoad'
      project: 'MasterData'
      source: 'MasterData.DB.DataLoad'
      branch: 'MDVersionUpgrade/Lonestar'

stages:
  - stage: Initialize
    displayName: 'Initialize and Select Targets'
    jobs:
      - job: Initialize_Env
        displayName: 'Initialize'
        steps:
          - checkout: none
          - task: PowerShell@2
            displayName: 'Build Information'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Branch: $(BranchName)"
                Write-Host "Build: $(BuildNumber)"
                Write-Host "Version: $(BuildVersion)"
                Write-Host "Database Slot: $(dbSlot)"
                Write-Host "Database configuration will be loaded from variable group in deployment stage"

  - stage: AcquireAndCopy
    displayName: 'Acquire, Extract and Copy Artifacts'
    dependsOn: Initialize
    condition: succeeded()
    variables:
      # Load variable groups at stage level for copy task
      - ${{ if eq(parameters.dbSlot, 'Dev') }}:
          - group: Development_Dataload
      - ${{ if eq(parameters.dbSlot, 'FT1') }}:
          - group: FT1_Dataload
      - ${{ if eq(parameters.dbSlot, 'FT2') }}:
          - group: FT2_Dataload
      - ${{ if eq(parameters.dbSlot, 'FT3') }}:
          - group: FT3_Dataload
      - ${{ if eq(parameters.dbSlot, 'QA') }}:
          - group: QA_Dataload
      - ${{ if eq(parameters.dbSlot, 'R1') }}:
          - group: R1_Dataload
      - ${{ if eq(parameters.dbSlot, 'Demo') }}:
          - group: Demo_Dataload
      - ${{ if eq(parameters.dbSlot, 'SIT') }}:
          - group: SIT_Dataload
      - ${{ if eq(parameters.dbSlot, 'Pre-Prod') }}:
          - group: Pre-Prod_Dataload
      - ${{ if eq(parameters.dbSlot, 'Production') }}:
          - group: Production_Dataload
    jobs:
      - job: PrepareAndCopyArtifacts
        displayName: 'Download, Extract and Copy DACPAC'
        steps:
          - checkout: none
          - download: 'MasterData.DB.DataLoad'
            displayName: 'Download artifacts'
            artifact: 'drop'
          - task: PowerShell@2
            displayName: 'Find zip file to copy'
            inputs:
              targetType: 'inline'
              script: |
                $dropPath = "$(Pipeline.Workspace)\MasterData.DB.DataLoad\drop"
                Write-Host "Looking for zip file in: $dropPath"
                
                if (-not (Test-Path $dropPath)) {
                  throw "Drop folder does not exist: $dropPath"
                }
                
                $zipFiles = Get-ChildItem -Path $dropPath -Filter "*.zip" -ErrorAction SilentlyContinue
                if (-not $zipFiles -or $zipFiles.Count -eq 0) {
                  Write-Host "ERROR: No zip files found in $dropPath"
                  Write-Host "Contents of drop folder:"
                  Get-ChildItem -Path $dropPath | ForEach-Object { Write-Host "  - $($_.Name)" }
                  throw "No zip file found in drop folder"
                }
                
                $zipFile = $zipFiles[0].FullName
                Write-Host "Found zip file: $zipFile"
                # Normalize path separators for Windows
                $zipFileNormalized = $zipFile -replace '/', '\'
                Write-Host "Normalized path: $zipFileNormalized"
                Write-Host "##vso[task.setvariable variable=ZipFilePath]$zipFileNormalized"
          - task: WindowsMachineFileCopy@2
            displayName: 'Copy artifact zip to destination server'
            inputs:
              SourcePath: '$(ZipFilePath)'
              MachineNames: "$(selectedDbServers)"
              AdminUserName: "$(winrmUserName)"
              AdminPassword: "$(winrmPassword)"
              TargetPath: 'C:\Temp\DataLoadDeploy'
              Protocol: "WinRM"
          - task: PowerShellOnTargetMachines@3
            displayName: 'Extract files on target server'
            inputs:
              Machines: "$(selectedDbServers)"
              UserName: "$(winrmUserName)"
              UserPassword: "$(winrmPassword)"
              InlineScript: |
                $tempFolder = 'C:\Temp\DataLoadDeploy'
                $deploymentPath = "$(DataLoad_Deployment_Path)"
                
                Write-Host "Checking for zip file in: $tempFolder"
                $zipFiles = Get-ChildItem -Path $tempFolder -Filter "*.zip" -ErrorAction SilentlyContinue
                
                if (-not $zipFiles -or $zipFiles.Count -eq 0) {
                  Write-Host "ERROR: No zip files found in $tempFolder"
                  if (Test-Path $tempFolder) {
                    Write-Host "Contents of temp folder:"
                    Get-ChildItem -Path $tempFolder | ForEach-Object { Write-Host "  - $($_.Name)" }
                  }
                  throw "Zip file not found in $tempFolder"
                }
                
                $zipPath = $zipFiles[0].FullName
                Write-Host "Found zip file: $zipPath"
                
                if (-not (Test-Path $deploymentPath)) {
                  Write-Host "Creating deployment folder: $deploymentPath"
                  New-Item -ItemType Directory -Path $deploymentPath -Force | Out-Null
                } else {
                  Write-Host "Clearing existing contents in: $deploymentPath"
                  Get-ChildItem -Path $deploymentPath -Recurse -Force | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                }
                
                Write-Host "Extracting $zipPath to $deploymentPath"
                Expand-Archive -LiteralPath $zipPath -DestinationPath $deploymentPath -Force
                Write-Host "Extraction completed successfully"
                
                # Verify DACPAC file exists
                $dacpacFiles = Get-ChildItem -Path $deploymentPath -Filter "*.dacpac" -Recurse -ErrorAction SilentlyContinue
                if ($dacpacFiles) {
                  Write-Host "DACPAC file(s) found:"
                  foreach ($file in $dacpacFiles) {
                    Write-Host "  - $($file.FullName)"
                  }
                } else {
                  Write-Host "WARNING: No DACPAC files found after extraction"
                }
              NewPsSessionOptionArguments: >
                -SkipCACheck
                -SkipCNCheck
                -SkipRevocationCheck
                -IdleTimeout 7200000
                -OperationTimeout 0
                -OutputBufferingMode Block

  - stage: DeployDatabase
    displayName: 'Deploy Database'
    dependsOn: AcquireAndCopy
    condition: succeeded()
    variables:
      # Load variable groups at stage level for PowerShell script access
      - ${{ if eq(parameters.dbSlot, 'Dev') }}:
          - group: Development_Dataload
      - ${{ if eq(parameters.dbSlot, 'FT1') }}:
          - group: FT1_Dataload
      - ${{ if eq(parameters.dbSlot, 'FT2') }}:
          - group: FT2_Dataload
      - ${{ if eq(parameters.dbSlot, 'FT3') }}:
          - group: FT3_Dataload
      - ${{ if eq(parameters.dbSlot, 'QA') }}:
          - group: QA_Dataload
      - ${{ if eq(parameters.dbSlot, 'R1') }}:
          - group: R1_Dataload
      - ${{ if eq(parameters.dbSlot, 'Demo') }}:
          - group: Demo_Dataload
      - ${{ if eq(parameters.dbSlot, 'SIT') }}:
          - group: SIT_Dataload
      - ${{ if eq(parameters.dbSlot, 'Pre-Prod') }}:
          - group: Pre-Prod_Dataload
      - ${{ if eq(parameters.dbSlot, 'Production') }}:
          - group: Production_Dataload
    jobs:
      - job: Deploy_DACPAC
        displayName: 'Deploy DACPAC to Database Server(s)'
        steps:
          - checkout: none
          - task: PowerShellOnTargetMachines@3
            displayName: 'Deploy DACPAC using SqlPackage'
            inputs:
              Machines: "$(selectedDbServers)"
              UserName: "$(winrmUserName)"
              UserPassword: "$(winrmPassword)"
              InlineScript: |
                $ErrorActionPreference = "Stop"
                
                # Get variables from Azure DevOps (expanded before script execution)
                $installLocation = "$(DataLoad_Deployment_Path)"
                # Server_DB_Instance_Name from variable group = SQL Server instance name to connect to
                $serverNames = "$(Server_DB_Instance_Name)"
                $dbName = "$(Database_MasterData_DBName)"
                $dacLocation = "$(Server_DAC_LibraryLocation)"
                $sqlUser = "$(Server_DB_Admin_User)"
                $sqlPassword = "$(Server_DB_Admin_Password)"
                
                # Database Details
                $projectName = "Boots.MasterData.DB.DataLoad"
                
                # Debug: List all files in temp_managed folder
                Write-Host "Checking for DACPAC file in: $installLocation"
                if (Test-Path $installLocation) {
                  Write-Host "Files found in temp_managed folder:"
                  Get-ChildItem -Path $installLocation -Recurse | ForEach-Object {
                    Write-Host "  - $($_.FullName) (Size: $($_.Length) bytes)"
                  }
                  
                  # Try to find DACPAC file (case-insensitive search)
                  $dacpacFiles = Get-ChildItem -Path $installLocation -Filter "*.dacpac" -Recurse -ErrorAction SilentlyContinue
                  if ($dacpacFiles) {
                    Write-Host "Found DACPAC file(s):"
                    foreach ($file in $dacpacFiles) {
                      Write-Host "  - $($file.FullName)"
                    }
                    $dacpac = $dacpacFiles[0].FullName
                    Write-Host "Using DACPAC file: $dacpac"
                  } else {
                    # Fallback to expected path
                    $dacpac = Join-Path $installLocation "$($projectName).dacpac"
                    Write-Host "No DACPAC files found, checking expected path: $dacpac"
                  }
                } else {
                  $dacpac = Join-Path $installLocation "$($projectName).dacpac"
                  Write-Host "temp_managed folder does not exist: $installLocation"
                }
                
                # Validate required variables
                if ([string]::IsNullOrWhiteSpace($serverNames)) {
                  throw "Server_DB_Instance_Name is not set or is empty"
                }
                if ([string]::IsNullOrWhiteSpace($dbName)) {
                  throw "Database_MasterData_DBName is not set or is empty"
                }
                if ([string]::IsNullOrWhiteSpace($dacLocation)) {
                  throw "Server_DAC_LibraryLocation is not set or is empty"
                }
                if (-not (Test-Path $dacpac)) {
                  Write-Host "ERROR: DACPAC file not found at: $dacpac"
                  if (Test-Path $installLocation) {
                    Write-Host "Contents of $installLocation :"
                    Get-ChildItem -Path $installLocation -Recurse | ForEach-Object {
                      Write-Host "  - $($_.FullName)"
                    }
                  }
                  throw "DACPAC file not found at: $dacpac"
                }
                if (-not (Test-Path $dacLocation)) {
                  throw "SqlPackage.exe not found at: $dacLocation"
                }
                
                Write-Host "=========================================="
                Write-Host "Database Deployment Configuration"
                Write-Host "=========================================="
                Write-Host "DACPAC File: $dacpac"
                Write-Host "SqlPackage Location: $dacLocation"
                Write-Host "Database Name: $dbName"
                Write-Host "Server(s): $serverNames"
                Write-Host "SQL User: $(if ([string]::IsNullOrWhiteSpace($sqlUser)) { 'Windows Authentication' } else { $sqlUser })"
                Write-Host "=========================================="
                
                # Split comma-separated server names and deploy sequentially
                $servers = $serverNames -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
                
                if ($servers.Count -eq 0) {
                  throw "No valid server names found in Server_DB_Instance_Name"
                }
                
                Write-Host "Deploying to $($servers.Count) server(s) sequentially..."
                
                $deploymentErrors = @()
                $deploymentSuccess = @()
                
                foreach ($serverName in $servers) {
                  Write-Host ""
                  Write-Host "=========================================="
                  Write-Host "Deploying to server: $serverName"
                  Write-Host "=========================================="
                  
                  try {
                    # Change to SqlPackage directory
                    Push-Location $dacLocation
                    
                    # Build SqlPackage command arguments
                    $sqlPackageArgs = @(
                      "/Action:publish",
                      "/SourceFile:`"$dacpac`"",
                      "/TargetServerName:`"$serverName`"",
                      "/TargetDatabaseName:`"$dbName`"",
                      "/p:BlockOnPossibleDataLoss=false"
                    )
                    
                    # Add SQL authentication if credentials provided
                    if (-not [string]::IsNullOrWhiteSpace($sqlUser) -and -not [string]::IsNullOrWhiteSpace($sqlPassword)) {
                      Write-Host "Using SQL Server Authentication"
                      $sqlPackageArgs += "/TargetUser:`"$sqlUser`""
                      $sqlPackageArgs += "/TargetPassword:`"$sqlPassword`""
                    } else {
                      Write-Host "Using Windows Authentication"
                    }
                    
                    Write-Host "Executing SqlPackage.exe with arguments:"
                    Write-Host "  $($sqlPackageArgs -join ' ')"
                    
                    # Execute SqlPackage
                    $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo
                    $processStartInfo.FileName = $dacLocation
                    $processStartInfo.Arguments = $sqlPackageArgs -join ' '
                    $processStartInfo.UseShellExecute = $false
                    $processStartInfo.RedirectStandardOutput = $true
                    $processStartInfo.RedirectStandardError = $true
                    $processStartInfo.CreateNoWindow = $true
                    
                    $process = New-Object System.Diagnostics.Process
                    $process.StartInfo = $processStartInfo
                    
                    # Capture output
                    $outputBuilder = New-Object System.Text.StringBuilder
                    $errorBuilder = New-Object System.Text.StringBuilder
                    
                    $outputEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action {
                  param($sender, $e)
                  if ($e.Data) {
                    [void]$outputBuilder.AppendLine($e.Data)
                    Write-Host $e.Data
                  }
                }
                    
                    $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action {
                  param($sender, $e)
                  if ($e.Data) {
                    [void]$errorBuilder.AppendLine($e.Data)
                    Write-Host $e.Data -ForegroundColor Yellow
                  }
                }
                    
                    $process.Start() | Out-Null
                    $process.BeginOutputReadLine()
                    $process.BeginErrorReadLine()
                    $process.WaitForExit()
                    
                    Unregister-Event -SourceIdentifier $outputEvent.Name
                    Unregister-Event -SourceIdentifier $errorEvent.Name
                    
                    $exitCode = $process.ExitCode
                    $stdOutput = $outputBuilder.ToString()
                    $stdError = $errorBuilder.ToString()
                    
                    if ($exitCode -ne 0) {
                      $errorMessage = "SqlPackage.exe failed with exit code $exitCode for server $serverName"
                      Write-Host "ERROR: $errorMessage" -ForegroundColor Red
                      if ($stdError) {
                        Write-Host "Error Output:" -ForegroundColor Red
                        Write-Host $stdError -ForegroundColor Red
                      }
                      if ($stdOutput) {
                        Write-Host "Standard Output:" -ForegroundColor Yellow
                        Write-Host $stdOutput
                      }
                      $deploymentErrors += "$serverName : Exit Code $exitCode - $stdError"
                      throw $errorMessage
                    } else {
                      Write-Host "SUCCESS: Deployment completed successfully for server $serverName" -ForegroundColor Green
                      if ($stdOutput) {
                        Write-Host "Output:"
                        Write-Host $stdOutput
                      }
                      $deploymentSuccess += $serverName
                    }
                    
                  } catch {
                    $errorDetails = $_.Exception.Message
                    if ($_.Exception.InnerException) {
                      $errorDetails += " | Inner Exception: $($_.Exception.InnerException.Message)"
                    }
                    Write-Host "ERROR: Deployment failed for server $serverName" -ForegroundColor Red
                    Write-Host "Error: $errorDetails" -ForegroundColor Red
                    Write-Host "Stack Trace: $($_.ScriptStackTrace)" -ForegroundColor Red
                    $deploymentErrors += "$serverName : $errorDetails"
                    throw "Deployment to $serverName failed: $errorDetails"
                  } finally {
                    Pop-Location
                  }
                }
                
                Write-Host ""
                Write-Host "=========================================="
                Write-Host "Deployment Summary"
                Write-Host "=========================================="
                Write-Host "Total Servers: $($servers.Count)"
                Write-Host "Successful: $($deploymentSuccess.Count)"
                Write-Host "Failed: $($deploymentErrors.Count)"
                
                if ($deploymentSuccess.Count -gt 0) {
                  Write-Host ""
                  Write-Host "Successfully deployed to:" -ForegroundColor Green
                  foreach ($server in $deploymentSuccess) {
                    Write-Host "  - $server" -ForegroundColor Green
                  }
                }
                
                if ($deploymentErrors.Count -gt 0) {
                  Write-Host ""
                  Write-Host "Failed deployments:" -ForegroundColor Red
                  foreach ($error in $deploymentErrors) {
                    Write-Host "  - $error" -ForegroundColor Red
                  }
                  throw "One or more deployments failed. See details above."
                }
                
                Write-Host ""
                Write-Host "All deployments completed successfully!" -ForegroundColor Green
              NewPsSessionOptionArguments: >
                -SkipCACheck
                -SkipCNCheck
                -SkipRevocationCheck
                -IdleTimeout 7200000
                -OperationTimeout 0
                -OutputBufferingMode Block
