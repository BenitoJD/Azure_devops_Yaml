pool:
  name: ccoe-nprod-windows-mdp-01
trigger:
- none

# Add name template for pipeline run display
name: $(BuildDefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)_Sites[$(SelectedSites)]

parameters:
  # ============================================
  # DEPLOYMENT CONTROL - Runtime Selection
  # ============================================
  - name: DeployFT1
    displayName: 'Deploy FT1 Website'
    type: boolean
    default: true
  
  - name: DeployFT2
    displayName: 'Deploy FT2 Website'
    type: boolean
    default: true
  
  - name: DeployFT3
    displayName: 'Deploy FT3 Website'
    type: boolean
    default: true
  
  - name: DeployR1
    displayName: 'Deploy R1 Website'
    type: boolean
    default: true

variables:
  # Build Information
  BuildNumber: '$(Build.BuildNumber)'
  BranchName: '$(Build.SourceBranchName)'
  BuildVersion: '$(Build.BuildId)'
  
  # Paths
  DeploymentBasePath: 'D:\Deployments'
  BackupBasePath: 'D:\Backups'
  
  # Map parameters to variables for easier use in scripts
  Deploy.FT1: ${{ parameters.DeployFT1 }}
  Deploy.FT2: ${{ parameters.DeployFT2 }}
  Deploy.FT3: ${{ parameters.DeployFT3 }}
  Deploy.R1: ${{ parameters.DeployR1 }}
  
  # Create readable site list for pipeline name (simplified)
  SelectedSites: 'FT1 FT2 FT3 R1'
  
  # 4 Stakeholder Websites
  Stakeholder1.Name: 'FT1'
  Stakeholder1.Port: '8091'
  Stakeholder1.PhysicalPath: 'D:\inetpub\wwwroot\FT1.Main'
  Stakeholder1.AppPoolName: 'FT1AppPool'
  
  Stakeholder2.Name: 'FT2'
  Stakeholder2.Port: '8092'
  Stakeholder2.PhysicalPath: 'D:\inetpub\wwwroot\FT2.Main'
  Stakeholder2.AppPoolName: 'FT2AppPool'
  
  Stakeholder3.Name: 'FT3'
  Stakeholder3.Port: '8093'
  Stakeholder3.PhysicalPath: 'D:\inetpub\wwwroot\FT3.Main'
  Stakeholder3.AppPoolName: 'FT3AppPool'
  
  Stakeholder4.Name: 'R1'
  Stakeholder4.Port: '8094'
  Stakeholder4.PhysicalPath: 'D:\inetpub\wwwroot\R1.Main'
  Stakeholder4.AppPoolName: 'R1AppPool'

resources:
 pipelines:
   - pipeline: 'MasterData.Main'
     project: 'MasterData'
     source: 'MasterData.Main'
     branch: 'MDVersionUpgrade/Lonestar'

stages:
  - stage: DeployWebsites
    displayName: 'Deploy Selected Websites - Branch: $(BranchName) - Build: $(BuildNumber)'
    variables:
      - group: SIT_FT1
      - group: SIT_FT2
      - group: SIT_FT3
      - group: SIT_R1
    
    jobs:
      - deployment: DeployStakeholders
        displayName: 'Deploy Selected Websites [$(BranchName)] v$(BuildVersion) with SIT Configuration'
        workspace:
          clean: all
        environment: 
          name: SIT
          resourceType: virtualMachine
        strategy:
         runOnce:
           deploy:
             steps:
               - checkout: none
               
               # Display Build Information
               - task: PowerShell@2
                 displayName: 'üìã Build Info - Branch: $(BranchName) | Build: $(BuildNumber) | Version: $(BuildVersion)'
                 inputs:
                   targetType: 'inline'
                   script: |
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "DEPLOYMENT INFORMATION" -ForegroundColor Cyan
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "Branch Name    : $(BranchName)" -ForegroundColor Yellow
                      Write-Host "Build Number   : $(BuildNumber)" -ForegroundColor Yellow
                      Write-Host "Build Version  : $(BuildVersion)" -ForegroundColor Yellow
                      Write-Host "Build ID       : $(Build.BuildId)" -ForegroundColor Yellow
                      Write-Host "Source Version : $(Build.SourceVersion)" -ForegroundColor Yellow
                      Write-Host "Started By     : $(Build.RequestedFor)" -ForegroundColor Yellow
                      Write-Host "Started At     : $(System.TeamProject)" -ForegroundColor Yellow
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "DEPLOYMENT TARGETS" -ForegroundColor Cyan
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "FT1          : $(Deploy.FT1)" -ForegroundColor $(if ("$(Deploy.FT1)" -eq "true") { "Green" } else { "Red" })
                      Write-Host "FT2          : $(Deploy.FT2)" -ForegroundColor $(if ("$(Deploy.FT2)" -eq "true") { "Green" } else { "Red" })
                      Write-Host "FT3          : $(Deploy.FT3)" -ForegroundColor $(if ("$(Deploy.FT3)" -eq "true") { "Green" } else { "Red" })
                      Write-Host "R1           : $(Deploy.R1)" -ForegroundColor $(if ("$(Deploy.R1)" -eq "true") { "Green" } else { "Red" })
                      Write-Host "================================================" -ForegroundColor Cyan
               
               # Display Selected Deployment Sites
               - task: PowerShell@2
                 displayName: 'üéØ Selected Deployment Sites'
                 inputs:
                   targetType: 'inline'
                   script: |
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "SELECTED DEPLOYMENT SITES" -ForegroundColor Cyan
                      Write-Host "================================================" -ForegroundColor Cyan
                      
                      $selectedSites = @()
                      $deploymentSummary = @()
                      
                      if ("$(Deploy.FT1)" -eq "true") { 
                        $selectedSites += "FT1"
                        $deploymentSummary += "‚úÖ FT1 (Port 8091)"
                      }
                      if ("$(Deploy.FT2)" -eq "true") { 
                        $selectedSites += "FT2"
                        $deploymentSummary += "‚úÖ FT2 (Port 8092)"
                      }
                      if ("$(Deploy.FT3)" -eq "true") { 
                        $selectedSites += "FT3"
                        $deploymentSummary += "‚úÖ FT3 (Port 8093)"
                      }
                      if ("$(Deploy.R1)" -eq "true") { 
                        $selectedSites += "R1"
                        $deploymentSummary += "‚úÖ R1 (Port 8094)"
                      }
                      
                      if ($selectedSites.Count -eq 0) {
                        Write-Host "‚ö†Ô∏è  NO SITES SELECTED FOR DEPLOYMENT" -ForegroundColor Red
                        Write-Host "All deployment flags are set to false" -ForegroundColor Yellow
                      } else {
                        Write-Host "Sites selected for deployment: $($selectedSites -join ', ')" -ForegroundColor Green
                        Write-Host ""
                        foreach ($site in $deploymentSummary) {
                           Write-Host $site -ForegroundColor White
                        }
                        Write-Host ""
                        Write-Host "Total sites to deploy: $($selectedSites.Count)" -ForegroundColor Cyan
                      }
                      
                      Write-Host "================================================" -ForegroundColor Cyan
               
               # Download Build Artifacts
               - download: 'MasterData.Main'
                 displayName: '‚¨áÔ∏è Download Artifacts - $(BranchName) Build $(BuildNumber)'
                 artifact: 'drop'
               
               # Backup Current Deployments
               - task: PowerShell@2
                 displayName: 'üíæ Backup Current Deployments - $(BranchName)'
                 inputs:
                   targetType: 'inline'
                   script: |
                      $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                      $branchName = "$(BranchName)"
                      $buildNumber = "$(BuildNumber)"
                      
                      # Create backup directory
                      if (-not (Test-Path "$(BackupBasePath)")) {
                        New-Item -ItemType Directory -Path "$(BackupBasePath)" -Force | Out-Null
                      }
                      
                      Write-Host "Creating backup for Branch: $branchName, Build: $buildNumber" -ForegroundColor Cyan
                      
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.R1)"}
                      )
                      
                      foreach ($stakeholder in $stakeholders) {
                        if ($stakeholder.Deploy -eq "true") {
                           $backupPath = "$(BackupBasePath)\$($stakeholder.Name)_${branchName}_${buildNumber}_$timestamp"
                           
                           if (Test-Path $stakeholder.Path) {
                             Write-Host "Backing up $($stakeholder.Name)..." -ForegroundColor Cyan
                             New-Item -ItemType Directory -Path $backupPath -Force | Out-Null
                             Copy-Item -Path "$($stakeholder.Path)\*" -Destination $backupPath -Recurse -Force
                             Write-Host "Backup completed: $backupPath" -ForegroundColor Green
                           }
                        } else {
                           Write-Host "Skipping backup for $($stakeholder.Name) (Deploy flag is false)" -ForegroundColor Yellow
                        }
                      }
                   errorActionPreference: 'continue'
               
               # Create Directories
               - task: PowerShell@2
                 displayName: 'üìÅ Create Required Directories'
                 inputs:
                   targetType: 'inline'
                   script: |
                      $directories = @()
                      
                      if ("$(Deploy.FT1)" -eq "true") { $directories += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.FT2)" -eq "true") { $directories += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.FT3)" -eq "true") { $directories += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.R1)" -eq "true") { $directories += "$(Stakeholder4.PhysicalPath)" }
                      $directories += "$(DeploymentBasePath)"
                      
                      foreach ($dir in $directories) {
                        if (-not (Test-Path $dir)) {
                           New-Item -ItemType Directory -Path $dir -Force | Out-Null
                           Write-Host "Created: $dir" -ForegroundColor Green
                        }
                      }
               
               # Extract Artifacts
               - task: ExtractFiles@1
                 displayName: 'üì¶ Extract Artifacts - Build $(BuildNumber)'
                 inputs:
                   archiveFilePatterns: '$(Pipeline.Workspace)/MasterData.Main/drop/*.zip'
                   destinationFolder: '$(DeploymentBasePath)'
                   cleanDestinationFolder: true
                   overwriteExistingFiles: true
               
               # Configure IIS
               - task: PowerShell@2
                 displayName: '‚öôÔ∏è Configure IIS Websites - $(BranchName)'
                 inputs:
                   targetType: 'inline'
                   script: |
                      # Try to import WebAdministration module
                      try {
                        Import-Module WebAdministration -ErrorAction Stop
                        Write-Host "WebAdministration module loaded successfully" -ForegroundColor Green
                      } catch {
                        Write-Host "WebAdministration module not available, using alternative method" -ForegroundColor Yellow
                        # Use appcmd.exe instead
                        $useAppCmd = $true
                      }
                      
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Port="$(Stakeholder1.Port)"; Path="$(Stakeholder1.PhysicalPath)"; AppPool="$(Stakeholder1.AppPoolName)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; Port="$(Stakeholder2.Port)"; Path="$(Stakeholder2.PhysicalPath)"; AppPool="$(Stakeholder2.AppPoolName)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; Port="$(Stakeholder3.Port)"; Path="$(Stakeholder3.PhysicalPath)"; AppPool="$(Stakeholder3.AppPoolName)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; Port="$(Stakeholder4.Port)"; Path="$(Stakeholder4.PhysicalPath)"; AppPool="$(Stakeholder4.AppPoolName)"; Deploy="$(Deploy.R1)"}
                      )
                      
                      foreach ($stakeholder in $stakeholders) {
                        if ($stakeholder.Deploy -eq "true") {
                           Write-Host "Configuring $($stakeholder.Name)..." -ForegroundColor Cyan
                           
                           if ($useAppCmd) {
                             # Use appcmd.exe for IIS management
                             try {
                               # Create Application Pool
                               & "C:\Windows\System32\inetsrv\appcmd.exe" add apppool /name:$($stakeholder.AppPool) /managedRuntimeVersion:v4.0 /managedPipelineMode:Integrated
                               Write-Host "Created App Pool: $($stakeholder.AppPool)" -ForegroundColor Green
                             } catch {
                               Write-Host "App Pool may already exist: $($stakeholder.AppPool)" -ForegroundColor Yellow
                             }
                             
                             try {
                               # Create Website
                               & "C:\Windows\System32\inetsrv\appcmd.exe" add site /name:$($stakeholder.Name) /physicalPath:$($stakeholder.Path) /bindings:http/*:$($stakeholder.Port):
                               & "C:\Windows\System32\inetsrv\appcmd.exe" set app "$($stakeholder.Name)/" /applicationPool:$($stakeholder.AppPool)
                               Write-Host "Created Website: $($stakeholder.Name)" -ForegroundColor Green
                             } catch {
                               Write-Host "Website may already exist: $($stakeholder.Name)" -ForegroundColor Yellow
                             }
                           } else {
                             # Use PowerShell cmdlets
                             try {
                               # Create Application Pool
                               New-WebAppPool -Name $stakeholder.AppPool -ErrorAction SilentlyContinue
                               Set-ItemProperty "IIS:\AppPools\$($stakeholder.AppPool)" -Name managedRuntimeVersion -Value "v4.0"
                               Set-ItemProperty "IIS:\AppPools\$($stakeholder.AppPool)" -Name managedPipelineMode -Value "Integrated"
                               Write-Host "Created App Pool: $($stakeholder.AppPool)" -ForegroundColor Green
                             } catch {
                               Write-Host "App Pool may already exist: $($stakeholder.AppPool)" -ForegroundColor Yellow
                             }
                             
                             try {
                               # Create Website
                               New-Website -Name $stakeholder.Name -PhysicalPath $stakeholder.Path -ApplicationPool $stakeholder.AppPool -Port $stakeholder.Port -ErrorAction SilentlyContinue
                               Write-Host "Created Website: $($stakeholder.Name)" -ForegroundColor Green
                             } catch {
                               Write-Host "Website may already exist: $($stakeholder.Name)" -ForegroundColor Yellow
                             }
                           }
                           
                           Write-Host "$($stakeholder.Name) configured" -ForegroundColor Green
                        } else {
                           Write-Host "Skipping configuration for $($stakeholder.Name) (Deploy flag is false)" -ForegroundColor Yellow
                        }
                      }
               
               # Deploy Files
               - task: PowerShell@2
                 displayName: 'üöÄ Deploy Files to All Websites - Build $(BuildNumber)'
                 inputs:
                   targetType: 'inline'
                   script: |
                      Write-Host "Deploying Build $(BuildNumber) from Branch $(BranchName)" -ForegroundColor Cyan
                      
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.R1)"}
                      )
                      
                      foreach ($stakeholder in $stakeholders) {
                        if ($stakeholder.Deploy -eq "true") {
                           Write-Host "Deploying to $($stakeholder.Name)..." -ForegroundColor Cyan
                           
                           # Clear and copy files
                           if (Test-Path $stakeholder.Dest) {
                             Get-ChildItem -Path $stakeholder.Dest -Exclude "App_Data" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                           }
                           Copy-Item -Path "$($stakeholder.Source)\*" -Destination $stakeholder.Dest -Recurse -Force
                           
                           Write-Host "$($stakeholder.Name) deployed successfully" -ForegroundColor Green
                        } else {
                           Write-Host "Skipping deployment for $($stakeholder.Name) (Deploy flag is false)" -ForegroundColor Yellow
                        }
                      }
               
               # Inject SIT Configuration into web.config
               - task: PowerShell@2
                 displayName: 'üîß Inject SIT Configuration into web.config'
                 inputs:
                   targetType: 'inline'
                   script: |
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "üîß SIT CONFIGURATION INJECTION" -ForegroundColor Cyan
                      Write-Host "================================================" -ForegroundColor Cyan
                      
                      # Enhanced stakeholder configuration with better error handling
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; Path="$(Stakeholder1.PhysicalPath)"; Deploy="$(Deploy.FT1)"; Port="$(Stakeholder1.Port)"; VarGroup="SIT_FT1"},
                        @{Name="$(Stakeholder2.Name)"; Path="$(Stakeholder2.PhysicalPath)"; Deploy="$(Deploy.FT2)"; Port="$(Stakeholder2.Port)"; VarGroup="SIT_FT2"},
                        @{Name="$(Stakeholder3.Name)"; Path="$(Stakeholder3.PhysicalPath)"; Deploy="$(Deploy.FT3)"; Port="$(Stakeholder3.Port)"; VarGroup="SIT_FT3"},
                        @{Name="$(Stakeholder4.Name)"; Path="$(Stakeholder4.PhysicalPath)"; Deploy="$(Deploy.R1)"; Port="$(Stakeholder4.Port)"; VarGroup="SIT_R1"}
                      )
                      
                      $totalUpdated = 0
                      $totalSkipped = 0
                      $processedSites = 0
                      
                      # üîç DIAGNOSTIC: Show all available variable groups and their variables
                      Write-Host "================================================" -ForegroundColor Magenta
                      Write-Host "üîç VARIABLE GROUP DIAGNOSTICS" -ForegroundColor Magenta
                      Write-Host "================================================" -ForegroundColor Magenta
                      
                      # Show ALL environment variables for debugging (filtered like your working diagnostic)
                      Write-Host "`nüîç ALL ENVIRONMENT VARIABLES (filtered):" -ForegroundColor Yellow
                      Get-ChildItem Env: | Where-Object { 
                          $_.Name -notlike "AGENT_*" -and 
                          $_.Name -notlike "SYSTEM_*" -and 
                          $_.Name -notlike "BUILD_*" -and
                          $_.Name -notlike "TF_*" -and
                          $_.Name -notlike "AZURE_*" -and
                          $_.Name -notlike "VSTS_*"
                      } | Sort-Object Name | ForEach-Object {
                          Write-Host "   $($_.Name) = $($_.Value)" -ForegroundColor Gray
                      }
                      
                      # Show variables that might be related to our variable groups
                      Write-Host "`nüîç VARIABLES CONTAINING 'SIT':" -ForegroundColor Yellow
                      Get-ChildItem Env: | Where-Object { $_.Name -like "*SIT*" } | ForEach-Object {
                          Write-Host "   $($_.Name) = $($_.Value)" -ForegroundColor Cyan
                      }
                      
                      $allVarGroups = @("SIT_FT1", "SIT_FT2", "SIT_FT3", "SIT_R1")
                      
                      foreach ($varGroup in $allVarGroups) {
                          Write-Host "`nüì¶ Variable Group: $varGroup" -ForegroundColor Yellow
                          Write-Host "   Looking for variables with prefix: $varGroup" -ForegroundColor Gray
                          
                          $groupVariables = @{}
                          
                          # Try both dot notation and underscore notation
                          $dotPrefix = "$varGroup."
                          $underscorePrefix = "$varGroup" + "_"
                          
                          # Get all environment variables that start with this variable group name (dot notation)
                          Get-ChildItem Env: | Where-Object { 
                              $_.Name -like "$dotPrefix*" -and 
                              $_.Value -and 
                              $_.Value.Trim() -ne "" 
                          } | ForEach-Object {
                              $varName = $_.Name.Substring($dotPrefix.Length)
                              $varValue = $_.Value
                              $groupVariables[$varName] = $varValue
                              Write-Host "   ‚úÖ Found (dot): $varName = $varValue" -ForegroundColor Green
                          }
                          
                          # Get all environment variables that start with this variable group name (underscore notation)
                          Get-ChildItem Env: | Where-Object { 
                              $_.Name -like "$underscorePrefix*" -and 
                              $_.Value -and 
                              $_.Value.Trim() -ne "" 
                          } | ForEach-Object {
                              $varName = $_.Name.Substring($underscorePrefix.Length)
                              $varValue = $_.Value
                              $groupVariables[$varName] = $varValue
                              Write-Host "   ‚úÖ Found (underscore): $varName = $varValue" -ForegroundColor Green
                          }
                          
                          if ($groupVariables.Count -eq 0) {
                              Write-Host "   ‚ö†Ô∏è  No variables found for $varGroup" -ForegroundColor Red
                          } else {
                              Write-Host "   üìä Total variables found: $($groupVariables.Count)" -ForegroundColor Cyan
                          }
                      }
                      
                      Write-Host "`n================================================" -ForegroundColor Magenta
                      Write-Host "üîß STARTING CONFIGURATION INJECTION" -ForegroundColor Magenta
                      Write-Host "================================================" -ForegroundColor Magenta
                      
                      # Get only variables from the specific variable group for this site
                      function Get-SITVariables {
                          param($varGroupName)
                          $siteVariables = @{}
                          
                          # Try multiple patterns to find variables from the variable group
                          # Pattern 1: SIT_FT1.VariableName (dot notation)
                          $varGroupPrefix1 = "$varGroupName."
                          Get-ChildItem Env: | Where-Object { 
                              $_.Name -like "$varGroupPrefix1*" -and 
                              $_.Value -and 
                              $_.Value.Trim() -ne "" 
                          } | ForEach-Object {
                              $varName = $_.Name.Substring($varGroupPrefix1.Length)
                              $varValue = $_.Value
                              $siteVariables[$varName] = $varValue
                              Write-Host "  üìã Found config variable (dot): $varName" -ForegroundColor DarkCyan
                          }
                          
                          # Pattern 2: SIT_FT1_VariableName (underscore notation)
                          $varGroupPrefix2 = "$varGroupName" + "_"
                          Get-ChildItem Env: | Where-Object { 
                              $_.Name -like "$varGroupPrefix2*" -and 
                              $_.Value -and 
                              $_.Value.Trim() -ne "" 
                          } | ForEach-Object {
                              $varName = $_.Name.Substring($varGroupPrefix2.Length)
                              $varValue = $_.Value
                              $siteVariables[$varName] = $varValue
                              Write-Host "  üìã Found config variable (underscore): $varName" -ForegroundColor DarkCyan
                          }
                          
                          # Pattern 3: Just the variable name (no prefix)
                          # This would require knowing the specific variable names
                          # For now, we'll rely on the patterns above
                          
                          Write-Host "  üîç Found $($siteVariables.Count) configuration variables from $varGroupName" -ForegroundColor Cyan
                          return $siteVariables
                      }
                      
                      # Enhanced web.config processing with better error handling
                      function Process-WebConfig {
                           param($stakeholder, $allVariables)
                           
                           $webConfigPath = Join-Path $stakeholder.Path "web.config"
                           
                           if (-not (Test-Path $webConfigPath)) {
                               Write-Host "  ‚ö†Ô∏è  web.config not found at: $webConfigPath" -ForegroundColor Yellow
                               return @{ Updated = 0; Skipped = 0; Errors = 1 }
                           }
                           
                           try {
                               # Read and validate web.config
                               [xml]$webConfig = Get-Content $webConfigPath -ErrorAction Stop
                               
                               if (-not $webConfig.configuration) {
                                   Write-Host "  ‚ùå Invalid web.config structure - missing configuration root" -ForegroundColor Red
                                   return @{ Updated = 0; Skipped = 0; Errors = 1 }
                               }
                               
                               $updatedCount = 0
                               $skippedCount = 0
                               
                              # Get ALL existing keys from web.config
                              $existingAppSettings = @{}
                              $existingConnectionStrings = @{}
                              
                              # Extract AppSettings keys
                              if ($webConfig.configuration.appSettings) {
                                  $webConfig.configuration.appSettings.add | ForEach-Object {
                                      $existingAppSettings[$_.key] = $_.value
                                  }
                              }
                              
                              # Extract ConnectionString names
                              if ($webConfig.configuration.connectionStrings) {
                                  $webConfig.configuration.connectionStrings.add | ForEach-Object {
                                      $existingConnectionStrings[$_.name] = $_.connectionString
                                  }
                              }
                              
                              Write-Host "  üìã Found $($existingAppSettings.Count) AppSettings and $($existingConnectionStrings.Count) ConnectionStrings in web.config" -ForegroundColor Cyan
                              
                            # Enhanced matching with case-insensitive mapping and key transformation
                            foreach ($variable in $allVariables.GetEnumerator()) {
                                $varName = $variable.Key
                                $varValue = $variable.Value
                                $matched = $false
                                
                                # Skip system and Azure DevOps variables that shouldn't be injected
                                if ($varName -match '^(Build|Agent|Pipeline|System|TF_|AZURE_|VSTS_)') {
                                    Write-Host "    ‚è≠Ô∏è  Skipped: $varName (system variable)" -ForegroundColor Gray
                                    $skippedCount++
                                    continue
                                }
                                
                                # Create mapping from variable names to web.config keys
                                $keyMapping = @{
                                    'MDSERVICEURL' = 'MDServiceUrl'
                                    'OBDCONTEXT' = 'OBDContext'
                                    'REPORTSERVERFOLDERNAME' = 'ReportServerFolderName'
                                    'REPORTSERVERURL' = 'ReportServerUrl'
                                    'REPORTSERVERWEBSERVICEURL' = 'ReportServerWebServiceUrl'
                                    'SERVER_REPORTSERVICE_URI' = 'Server_ReportService_URI'
                                    'SITEEDITORTOOL_LOCATION' = 'SiteEditorTool_Location'
                                }
                                
                                # Special handling for connection strings
                                $connectionStringKeys = @('OBDCONTEXT')
                                
                                # Get the mapped key name (case-sensitive match)
                                $mappedKey = if ($keyMapping.ContainsKey($varName)) { $keyMapping[$varName] } else { $varName }
                                
                                # Check if this is a connection string variable
                                $isConnectionString = $connectionStringKeys -contains $varName
                                
                                # Try ConnectionStrings first if this is a known connection string variable
                                if ($isConnectionString) {
                                    $connectionKey = $null
                                    foreach ($key in $existingConnectionStrings.Keys) {
                                        if ($key -eq $mappedKey -or $key -ieq $varName) {
                                            $connectionKey = $key
                                            break
                                        }
                                    }
                                    
                                    if ($connectionKey) {
                                        $existingConnection = $webConfig.configuration.connectionStrings.SelectSingleNode("add[@name='$connectionKey']")
                                        if ($existingConnection) {
                                            $oldValue = $existingConnection.connectionString
                                            $existingConnection.connectionString = $varValue
                                            Write-Host "    ‚úÖ Updated ConnectionString: $connectionKey = $varValue" -ForegroundColor Green
                                            if ($oldValue -ne $varValue) {
                                                Write-Host "      üìù Previous value: $oldValue" -ForegroundColor DarkGray
                                            }
                                            $updatedCount++
                                            $matched = $true
                                        }
                                    }
                                }
                                
                                # Try AppSettings if not matched and not a connection string
                                if (-not $matched -and -not $isConnectionString) {
                                    $appSettingKey = $null
                                    foreach ($key in $existingAppSettings.Keys) {
                                        if ($key -eq $mappedKey -or $key -ieq $varName) {
                                            $appSettingKey = $key
                                            break
                                        }
                                    }
                                    
                                    if ($appSettingKey) {
                                        $existingSetting = $webConfig.configuration.appSettings.SelectSingleNode("add[@key='$appSettingKey']")
                                        if ($existingSetting) {
                                            $oldValue = $existingSetting.value
                                            $existingSetting.value = $varValue
                                            Write-Host "    ‚úÖ Updated AppSetting: $appSettingKey = $varValue" -ForegroundColor Green
                                            if ($oldValue -ne $varValue) {
                                                Write-Host "      üìù Previous value: $oldValue" -ForegroundColor DarkGray
                                            }
                                            $updatedCount++
                                            $matched = $true
                                        }
                                    }
                                }
                                
                                # Try ConnectionStrings as fallback if not matched yet
                                if (-not $matched) {
                                    $connectionKey = $null
                                    foreach ($key in $existingConnectionStrings.Keys) {
                                        if ($key -eq $mappedKey -or $key -ieq $varName) {
                                            $connectionKey = $key
                                            break
                                        }
                                    }
                                    
                                    if ($connectionKey) {
                                        $existingConnection = $webConfig.configuration.connectionStrings.SelectSingleNode("add[@name='$connectionKey']")
                                        if ($existingConnection) {
                                            $oldValue = $existingConnection.connectionString
                                            $existingConnection.connectionString = $varValue
                                            Write-Host "    ‚úÖ Updated ConnectionString: $connectionKey = $varValue" -ForegroundColor Green
                                            if ($oldValue -ne $varValue) {
                                                Write-Host "      üìù Previous value: $oldValue" -ForegroundColor DarkGray
                                            }
                                            $updatedCount++
                                            $matched = $true
                                        }
                                    }
                                }
                                
                                if (-not $matched) {
                                    Write-Host "    ‚è≠Ô∏è  Skipped: $varName (no matching key found in web.config)" -ForegroundColor Yellow
                                    $skippedCount++
                                }
                            }
                               
                               # Save with backup
                               $backupPath = "$webConfigPath.backup.$(Get-Date -Format 'yyyyMMdd_HHmmss')"
                               Copy-Item $webConfigPath $backupPath -Force
                               Write-Host "  üíæ Backup created: $backupPath" -ForegroundColor DarkCyan
                               
                               $webConfig.Save($webConfigPath)
                               Write-Host "  üíæ web.config saved successfully" -ForegroundColor Green
                               
                               return @{ Updated = $updatedCount; Skipped = $skippedCount; Errors = 0 }
                               
                           } catch {
                               Write-Host "  ‚ùå Error processing web.config: $($_.Exception.Message)" -ForegroundColor Red
                               return @{ Updated = 0; Skipped = 0; Errors = 1 }
                           }
                      }
                      
                      # Process each stakeholder
                      foreach ($stakeholder in $stakeholders) {
                           if ($stakeholder.Deploy -eq "true") {
                               Write-Host ""
                               Write-Host "üåê Processing $($stakeholder.Name) (Port: $($stakeholder.Port)) using $($stakeholder.VarGroup)..." -ForegroundColor Cyan
                               Write-Host "üìÅ Path: $($stakeholder.Path)" -ForegroundColor DarkCyan
                               
                            # Get variables for this site from Azure DevOps Variable Group
                            $allVariables = Get-SITVariables $stakeholder.VarGroup
                              
                              if ($allVariables.Count -eq 0) {
                                  Write-Host "  ‚ö†Ô∏è  No variables found in $($stakeholder.VarGroup) variable group" -ForegroundColor Yellow
                                  continue
                              }
                              
                              Write-Host "  üìä Found $($allVariables.Count) variables from $($stakeholder.VarGroup) variable group" -ForegroundColor Cyan
                              
                              # Process web.config with dynamic matching
                              $result = Process-WebConfig $stakeholder $allVariables
                               
                               $totalUpdated += $result.Updated
                               $totalSkipped += $result.Skipped
                               $processedSites++
                               
                               Write-Host "  üìà Result: $($result.Updated) updated, $($result.Skipped) skipped" -ForegroundColor $(if ($result.Errors -gt 0) { "Red" } else { "Green" })
                           } else {
                               Write-Host "‚è≠Ô∏è  Skipping $($stakeholder.Name) (Deploy flag is false)" -ForegroundColor Yellow
                           }
                      }
                      
                      # Final summary
                      Write-Host ""
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "üìä INJECTION SUMMARY" -ForegroundColor Cyan
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "Sites processed: $processedSites" -ForegroundColor White
                      Write-Host "Total settings updated: $totalUpdated" -ForegroundColor Green
                      Write-Host "Total settings skipped: $totalSkipped" -ForegroundColor Gray
                      Write-Host "================================================" -ForegroundColor Cyan
                      
                      if ($totalUpdated -gt 0) {
                           Write-Host "‚úÖ SIT configuration injection completed successfully!" -ForegroundColor Green
                      } else {
                           Write-Host "‚ö†Ô∏è  No settings were updated" -ForegroundColor Yellow
                      }
               
               # Set Permissions
               - task: PowerShell@2
                 displayName: 'üîí Set Folder Permissions'
                 inputs:
                   targetType: 'inline'
                   script: |
                      $paths = @()
                      
                      if ("$(Deploy.FT1)" -eq "true") { $paths += "$(Stakeholder1.PhysicalPath)" }
                      if ("$(Deploy.FT2)" -eq "true") { $paths += "$(Stakeholder2.PhysicalPath)" }
                      if ("$(Deploy.FT3)" -eq "true") { $paths += "$(Stakeholder3.PhysicalPath)" }
                      if ("$(Deploy.R1)" -eq "true") { $paths += "$(Stakeholder4.PhysicalPath)" }
                      
                      foreach ($path in $paths) {
                        $acl = Get-Acl $path
                        $iisUsersRule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS","FullControl","ContainerInherit,ObjectInherit","None","Allow")
                        $acl.SetAccessRule($iisUsersRule)
                        Set-Acl $path $acl
                        Write-Host "Permissions set for: $path" -ForegroundColor Green
                      }
               
               # Start Services
               - task: PowerShell@2
                 displayName: '‚ñ∂Ô∏è Start All Websites - $(BranchName) v$(BuildVersion)'
                 inputs:
                   targetType: 'inline'
                   script: |
                      # Try to import WebAdministration module
                      try {
                        Import-Module WebAdministration -ErrorAction Stop
                        Write-Host "WebAdministration module loaded successfully" -ForegroundColor Green
                        $usePowerShell = $true
                      } catch {
                        Write-Host "WebAdministration module not available, using appcmd.exe" -ForegroundColor Yellow
                        $usePowerShell = $false
                      }
                      
                      $stakeholders = @(
                        @{Name="$(Stakeholder1.Name)"; AppPool="$(Stakeholder1.AppPoolName)"; Port="$(Stakeholder1.Port)"; Deploy="$(Deploy.FT1)"},
                        @{Name="$(Stakeholder2.Name)"; AppPool="$(Stakeholder2.AppPoolName)"; Port="$(Stakeholder2.Port)"; Deploy="$(Deploy.FT2)"},
                        @{Name="$(Stakeholder3.Name)"; AppPool="$(Stakeholder3.AppPoolName)"; Port="$(Stakeholder3.Port)"; Deploy="$(Deploy.FT3)"},
                        @{Name="$(Stakeholder4.Name)"; AppPool="$(Stakeholder4.AppPoolName)"; Port="$(Stakeholder4.Port)"; Deploy="$(Deploy.R1)"}
                      )
                      
                      $deployedSites = @()
                      
                      foreach ($stakeholder in $stakeholders) {
                        if ($stakeholder.Deploy -eq "true") {
                           if ($usePowerShell) {
                             # Use PowerShell cmdlets with error handling
                             try {
                               Start-WebAppPool -Name $stakeholder.AppPool -ErrorAction SilentlyContinue
                               Write-Host "App Pool $($stakeholder.AppPool) started or already running" -ForegroundColor Green
                             } catch {
                               Write-Host "App Pool $($stakeholder.AppPool) may already be running" -ForegroundColor Yellow
                             }
                             
                             try {
                               Start-Website -Name $stakeholder.Name -ErrorAction SilentlyContinue
                               Write-Host "Website $($stakeholder.Name) started or already running" -ForegroundColor Green
                             } catch {
                               Write-Host "Website $($stakeholder.Name) may already be running" -ForegroundColor Yellow
                             }
                           } else {
                             # Use appcmd.exe with error handling
                             try {
                               & "C:\Windows\System32\inetsrv\appcmd.exe" start apppool /apppool.name:$($stakeholder.AppPool) 2>$null
                               Write-Host "App Pool $($stakeholder.AppPool) started or already running" -ForegroundColor Green
                             } catch {
                               Write-Host "App Pool $($stakeholder.AppPool) may already be running" -ForegroundColor Yellow
                             }
                             
                             try {
                               & "C:\Windows\System32\inetsrv\appcmd.exe" start site /site.name:$($stakeholder.Name) 2>$null
                               Write-Host "Website $($stakeholder.Name) started or already running" -ForegroundColor Green
                             } catch {
                               Write-Host "Website $($stakeholder.Name) may already be running" -ForegroundColor Yellow
                             }
                           }
                           Write-Host "$($stakeholder.Name) started" -ForegroundColor Green
                           $deployedSites += @{Name=$stakeholder.Name; Port=$stakeholder.Port}
                        } else {
                           Write-Host "Skipping start for $($stakeholder.Name) (Deploy flag is false)" -ForegroundColor Yellow
                        }
                      }
                      
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "DEPLOYMENT COMPLETED SUCCESSFULLY!" -ForegroundColor Green
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "Branch: $(BranchName)" -ForegroundColor Yellow
                      Write-Host "Build: $(BuildNumber)" -ForegroundColor Yellow
                      Write-Host "Version: $(BuildVersion)" -ForegroundColor Yellow
                      Write-Host "================================================" -ForegroundColor Cyan
                      Write-Host "DEPLOYED WEBSITES:" -ForegroundColor Cyan
                      Write-Host "================================================" -ForegroundColor Cyan
                      
                      if ($deployedSites.Count -eq 0) {
                        Write-Host "‚ö†Ô∏è  NO WEBSITES WERE DEPLOYED" -ForegroundColor Red
                        Write-Host "All deployment flags were set to false" -ForegroundColor Yellow
                      } else {
                        Write-Host "‚úÖ Successfully deployed $($deployedSites.Count) website(s):" -ForegroundColor Green
                        Write-Host ""
                        foreach ($site in $deployedSites) {
                           Write-Host "üåê $($site.Name): http://localhost:$($site.Port)" -ForegroundColor White
                        }
                        Write-Host ""
                        Write-Host "üîß SIT Configuration injected into all deployed sites" -ForegroundColor Cyan
                      }
                      
                      Write-Host "================================================" -ForegroundColor Cyan