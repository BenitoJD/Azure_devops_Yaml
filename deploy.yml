trigger:
- none

variables:
  # Build Information
  BuildConfiguration: 'Release'
  BuildPlatform: 'Any CPU'
  BuildNumber: '$(Build.BuildNumber)'
  BuildId: '$(Build.BuildId)'
  BranchName: '$(Build.SourceBranchName)'
  CommitId: '$(Build.SourceVersion)'
  BuildDate: '$(Date:yyyy-MM-dd)'
  BuildTime: '$(Date:HH:mm:ss)'
  
  # Environment Configuration
  Environment: 'SIT'
  DeploymentType: 'InPlace'
  
  # Paths Configuration
  DeploymentBasePath: 'D:\Deployments'
  BackupBasePath: 'D:\Backups'
  VersionMetadataPath: 'D:\Metadata'
  LogsPath: 'D:\Logs'
  
  # IIS Configuration
  IISLogPath: 'D:\Logs\IIS'
  AppPoolIdentity: 'ApplicationPoolIdentity'
  AppPoolManagedRuntimeVersion: 'v4.0'
  AppPoolManagedPipelineMode: 'Integrated'
  
  # Security Configuration
  BackupRetentionDays: 30
  MaxBackups: 10
  
  # Stakeholder Configuration
  Stakeholder1.Name: 'Finance'
  Stakeholder1.SiteName: 'Finance.Main'
  Stakeholder1.Port: '8091'
  Stakeholder1.PhysicalPath: 'D:\inetpub\wwwroot\Finance.Main'
  Stakeholder1.AppPoolName: 'FinanceAppPool'
  Stakeholder1.Description: 'Financial Management Portal'
  
  Stakeholder2.Name: 'Operations'
  Stakeholder2.SiteName: 'Operations.Main'
  Stakeholder2.Port: '8092'
  Stakeholder2.PhysicalPath: 'D:\inetpub\wwwroot\Operations.Main'
  Stakeholder2.AppPoolName: 'OperationsAppPool'
  Stakeholder2.Description: 'Operations Management Portal'
  
  Stakeholder3.Name: 'Management'
  Stakeholder3.SiteName: 'Management.Main'
  Stakeholder3.Port: '8093'
  Stakeholder3.PhysicalPath: 'D:\inetpub\wwwroot\Management.Main'
  Stakeholder3.AppPoolName: 'ManagementAppPool'
  Stakeholder3.Description: 'Executive Management Portal'
  
  Stakeholder4.Name: 'Partners'
  Stakeholder4.SiteName: 'Partners.Main'
  Stakeholder4.Port: '8094'
  Stakeholder4.PhysicalPath: 'D:\inetpub\wwwroot\Partners.Main'
  Stakeholder4.AppPoolName: 'PartnersAppPool'
  Stakeholder4.Description: 'External Partners Portal'

resources:
 pipelines:
   - pipeline: 'MasterData.Main'
     project: 'MasterData'
     source: 'MasterData.Main'
     branch: 'MDVersionUpgrade/Lonestar'

stages:
  # Pre-deployment validation and preparation
  - stage: PreDeployment
    displayName: 'Pre-Deployment Validation'
    jobs:
      - job: ValidateEnvironment
        displayName: 'Environment Validation'
        steps:
          - task: PowerShell@2
            displayName: 'Validate Prerequisites'
            inputs:
              targetType: 'inline'
              script: |
                # Check IIS installation
                if (-not (Get-WindowsFeature -Name IIS-WebServerRole -ErrorAction SilentlyContinue)) {
                  Write-Error "IIS is not installed or not available"
                  exit 1
                }
                
                # Check required modules
                if (-not (Get-Module -Name WebAdministration -ListAvailable)) {
                  Write-Error "WebAdministration module is not available"
                  exit 1
                }
                
                # Check disk space
                $drive = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='D:'"
                $freeSpaceGB = [math]::Round($drive.FreeSpace / 1GB, 2)
                if ($freeSpaceGB -lt 10) {
                  Write-Error "Insufficient disk space on D: drive. Available: $freeSpaceGB GB"
                  exit 1
                }
                
                Write-Host "Environment validation passed" -ForegroundColor Green
                Write-Host "Available disk space: $freeSpaceGB GB" -ForegroundColor Green

  # Main deployment stage - In-Place Deployment Strategy
  # Strategy: Backup → Deploy → Start (Single Server)
  - stage: DeployStakeholderWebsites
    displayName: 'Deploy Stakeholder Websites (In-Place)'
    dependsOn: PreDeployment
    condition: succeeded()
    
    jobs:
      - deployment: DeployStakeholders
        displayName: 'In-Place Deployment'
        workspace:
          clean: all
        environment: 
          name: SIT
          resourceType: virtualMachine
        strategy:
         runOnce:
           deploy:
             steps:
               - checkout: none
               
               # Download Build Artifacts
               - download: 'MasterData.Main'
                 displayName: 'Download Build Artifacts'
                 artifact: 'drop'
               
               # ==================== BACKUP CURRENT DEPLOYMENTS ====================
               - task: PowerShell@2
                 displayName: 'Create Pre-Deployment Backups'
                 inputs:
                   targetType: 'inline'
                   script: |
                     # Enhanced backup with industry standards
                     $ErrorActionPreference = 'Stop'
                     $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
                     $branchName = "$(BranchName)"
                     $buildNumber = "$(BuildNumber)"
                     $buildId = "$(BuildId)"
                     $commitId = "$(CommitId)"
                     
                     # Create directory structure
                     $directories = @("$(BackupBasePath)", "$(VersionMetadataPath)", "$(LogsPath)", "$(IISLogPath)")
                     foreach ($dir in $directories) {
                       if (-not (Test-Path $dir)) {
                         New-Item -ItemType Directory -Path $dir -Force | Out-Null
                         Write-Host "Created directory: $dir" -ForegroundColor Green
                       }
                     }
                     
                     # Import required modules
                     Import-Module WebAdministration -ErrorAction Stop
                     
                     $stakeholders = @(
                       @{Name="$(Stakeholder1.Name)"; SiteName="$(Stakeholder1.SiteName)"; Path="$(Stakeholder1.PhysicalPath)"; AppPool="$(Stakeholder1.AppPoolName)"; Description="$(Stakeholder1.Description)"},
                       @{Name="$(Stakeholder2.Name)"; SiteName="$(Stakeholder2.SiteName)"; Path="$(Stakeholder2.PhysicalPath)"; AppPool="$(Stakeholder2.AppPoolName)"; Description="$(Stakeholder2.Description)"},
                       @{Name="$(Stakeholder3.Name)"; SiteName="$(Stakeholder3.SiteName)"; Path="$(Stakeholder3.PhysicalPath)"; AppPool="$(Stakeholder3.AppPoolName)"; Description="$(Stakeholder3.Description)"},
                       @{Name="$(Stakeholder4.Name)"; SiteName="$(Stakeholder4.SiteName)"; Path="$(Stakeholder4.PhysicalPath)"; AppPool="$(Stakeholder4.AppPoolName)"; Description="$(Stakeholder4.Description)"}
                     )
                     
                     $backupResults = @()
                     
                     foreach ($stakeholder in $stakeholders) {
                       try {
                         Write-Host "Processing backup for $($stakeholder.Name)..." -ForegroundColor Cyan
                         
                         $backupPath = "$(BackupBasePath)\$($stakeholder.Name)_$timestamp"
                         $backupSize = 0
                         $backupStatus = "Success"
                         
                         if (Test-Path $stakeholder.Path) {
                           # Create backup directory
                           New-Item -ItemType Directory -Path $backupPath -Force | Out-Null
                           
                           # Copy files with progress
                           $files = Get-ChildItem -Path $stakeholder.Path -Recurse
                           $totalFiles = $files.Count
                           $copiedFiles = 0
                           
                           foreach ($file in $files) {
                             $relativePath = $file.FullName.Substring($stakeholder.Path.Length + 1)
                             $destinationPath = Join-Path $backupPath $relativePath
                             
                             if ($file.PSIsContainer) {
                               if (-not (Test-Path $destinationPath)) {
                                 New-Item -ItemType Directory -Path $destinationPath -Force | Out-Null
                               }
                             } else {
                               $destinationDir = Split-Path $destinationPath -Parent
                               if (-not (Test-Path $destinationDir)) {
                                 New-Item -ItemType Directory -Path $destinationDir -Force | Out-Null
                               }
                               Copy-Item -Path $file.FullName -Destination $destinationPath -Force
                               $backupSize += $file.Length
                             }
                             
                             $copiedFiles++
                             if ($copiedFiles % 100 -eq 0) {
                               Write-Host "Copied $copiedFiles of $totalFiles files..." -ForegroundColor Gray
                             }
                           }
                           
                           $backupSizeMB = [math]::Round($backupSize / 1MB, 2)
                           Write-Host "Backup completed: $backupSizeMB MB" -ForegroundColor Green
                         } else {
                           Write-Host "No existing deployment found for $($stakeholder.Name)" -ForegroundColor Yellow
                           $backupStatus = "NoExistingDeployment"
                         }
                         
                         # Create comprehensive metadata
                         $metadata = @{
                           DeploymentInfo = @{
                             StakeholderName = $stakeholder.Name
                             SiteName = $stakeholder.SiteName
                             AppPoolName = $stakeholder.AppPool
                             Description = $stakeholder.Description
                           }
                           BackupInfo = @{
                             BackupTimestamp = $timestamp
                             BackupPath = $backupPath
                             BackupSizeMB = $backupSizeMB
                             BackupStatus = $backupStatus
                           }
                           BuildInfo = @{
                             BranchName = $branchName
                             BuildNumber = $buildNumber
                             BuildId = $buildId
                             CommitId = $commitId
                             BuildDate = "$(BuildDate)"
                             BuildTime = "$(BuildTime)"
                           }
                           EnvironmentInfo = @{
                             Environment = "$(Environment)"
                             DeploymentType = "$(DeploymentType)"
                             ServerName = $env:COMPUTERNAME
                             UserName = $env:USERNAME
                           }
                           Paths = @{
                             DeploymentPath = $stakeholder.Path
                             BackupPath = $backupPath
                             LogsPath = "$(LogsPath)"
                             MetadataPath = "$(VersionMetadataPath)"
                           }
                         }
                         
                         $metadataPath = "$(VersionMetadataPath)\$($stakeholder.Name)_Backup_$timestamp.json"
                         $metadata | ConvertTo-Json -Depth 5 | Out-File -FilePath $metadataPath -Encoding UTF8
                         
                         $backupResults += @{
                           Stakeholder = $stakeholder.Name
                           Status = $backupStatus
                           SizeMB = $backupSizeMB
                           Path = $backupPath
                         }
                         
                         Write-Host "$($stakeholder.Name) backup completed successfully" -ForegroundColor Green
                         
                       } catch {
                         Write-Error "Failed to backup $($stakeholder.Name): $($_.Exception.Message)"
                         $backupResults += @{
                           Stakeholder = $stakeholder.Name
                           Status = "Failed"
                           Error = $_.Exception.Message
                         }
                       }
                     }
                     
                     # Cleanup old backups (retention policy)
                     Write-Host "Applying backup retention policy..." -ForegroundColor Cyan
                     $retentionDays = $(BackupRetentionDays)
                     $cutoffDate = (Get-Date).AddDays(-$retentionDays)
                     
                     foreach ($stakeholder in $stakeholders) {
                       $oldBackups = Get-ChildItem "$(BackupBasePath)" -Directory | Where-Object { 
                         $_.Name -like "*$($stakeholder.Name)*" -and $_.CreationTime -lt $cutoffDate 
                       }
                       
                       foreach ($oldBackup in $oldBackups) {
                         Write-Host "Removing old backup: $($oldBackup.Name)" -ForegroundColor Gray
                         Remove-Item $oldBackup.FullName -Recurse -Force
                       }
                     }
                     
                     # Summary
                     Write-Host "Backup Summary:" -ForegroundColor Cyan
                     foreach ($result in $backupResults) {
                       $statusColor = if ($result.Status -eq "Success") { "Green" } else { "Red" }
                       Write-Host "  $($result.Stakeholder): $($result.Status)" -ForegroundColor $statusColor
                     }
               
               # ==================== CREATE DIRECTORIES ====================
               - task: PowerShell@2
                 displayName: 'Create Required Directories'
                 inputs:
                   targetType: 'inline'
                   script: |
                     $directories = @(
                       "$(Stakeholder1.PhysicalPath)",
                       "$(Stakeholder2.PhysicalPath)",
                       "$(Stakeholder3.PhysicalPath)",
                       "$(Stakeholder4.PhysicalPath)",
                       "$(DeploymentBasePath)\Finance",
                       "$(DeploymentBasePath)\Operations",
                       "$(DeploymentBasePath)\Management",
                       "$(DeploymentBasePath)\Partners"
                     )
                     
                     foreach ($dir in $directories) {
                       if (-not (Test-Path $dir)) {
                         New-Item -ItemType Directory -Path $dir -Force | Out-Null
                         Write-Host "Created: $dir" -ForegroundColor Green
                       }
                     }
               
               # ==================== EXTRACT ARTIFACTS ====================
               - task: ExtractFiles@1
                 displayName: 'Extract Build Artifacts'
                 inputs:
                   archiveFilePatterns: '$(Pipeline.Workspace)/MasterData.Main/drop/*.zip'
                   destinationFolder: '$(DeploymentBasePath)'
                   cleanDestinationFolder: true
                   overwriteExistingFiles: true
               
               # ==================== CONFIGURE IIS INFRASTRUCTURE ====================
               - task: PowerShell@2
                 displayName: 'Configure IIS Infrastructure (Industry Standard)'
                 inputs:
                   targetType: 'inline'
                   script: |
                     # Industry Standard IIS Configuration
                     $ErrorActionPreference = 'Stop'
                     Import-Module WebAdministration -ErrorAction Stop
                     
                     $stakeholders = @(
                       @{Name="$(Stakeholder1.Name)"; SiteName="$(Stakeholder1.SiteName)"; Port="$(Stakeholder1.Port)"; Path="$(Stakeholder1.PhysicalPath)"; AppPool="$(Stakeholder1.AppPoolName)"; Description="$(Stakeholder1.Description)"},
                       @{Name="$(Stakeholder2.Name)"; SiteName="$(Stakeholder2.SiteName)"; Port="$(Stakeholder2.Port)"; Path="$(Stakeholder2.PhysicalPath)"; AppPool="$(Stakeholder2.AppPoolName)"; Description="$(Stakeholder2.Description)"},
                       @{Name="$(Stakeholder3.Name)"; SiteName="$(Stakeholder3.SiteName)"; Port="$(Stakeholder3.Port)"; Path="$(Stakeholder3.PhysicalPath)"; AppPool="$(Stakeholder3.AppPoolName)"; Description="$(Stakeholder3.Description)"},
                       @{Name="$(Stakeholder4.Name)"; SiteName="$(Stakeholder4.SiteName)"; Port="$(Stakeholder4.Port)"; Path="$(Stakeholder4.PhysicalPath)"; AppPool="$(Stakeholder4.AppPoolName)"; Description="$(Stakeholder4.Description)"}
                     )
                     
                     $configurationResults = @()
                     
                     foreach ($stakeholder in $stakeholders) {
                       try {
                         Write-Host "Configuring infrastructure for $($stakeholder.Name)..." -ForegroundColor Cyan
                         
                         # ========== APPLICATION POOL CONFIGURATION ==========
                         $appPoolCreated = $false
                         if (-not (Get-WebAppPool -Name $stakeholder.AppPool -ErrorAction SilentlyContinue)) {
                           Write-Host "Creating Application Pool: $($stakeholder.AppPool)" -ForegroundColor Yellow
                           New-WebAppPool -Name $stakeholder.AppPool
                           $appPoolCreated = $true
                         } else {
                           Write-Host "Application Pool exists: $($stakeholder.AppPool)" -ForegroundColor Gray
                         }
                         
                         # Configure Application Pool with industry standards
                         $appPoolPath = "IIS:\AppPools\$($stakeholder.AppPool)"
                         
                         # Basic Configuration
                         Set-ItemProperty $appPoolPath -Name managedRuntimeVersion -Value "$(AppPoolManagedRuntimeVersion)"
                     Set-ItemProperty $appPoolPath -Name managedPipelineMode -Value "$(AppPoolManagedPipelineMode)"
                         Set-ItemProperty $appPoolPath -Name processModel.identityType -Value "$(AppPoolIdentity)"
                         
                         # Performance Configuration
                     Set-ItemProperty $appPoolPath -Name startMode -Value "AlwaysRunning"
                         Set-ItemProperty $appPoolPath -Name processModel.idleTimeout -Value "00:20:00"
                         Set-ItemProperty $appPoolPath -Name processModel.loadUserProfile -Value $true
                         Set-ItemProperty $appPoolPath -Name processModel.maxProcesses -Value 1
                         
                         # Recycling Configuration
                     Set-ItemProperty $appPoolPath -Name recycling.periodicRestart.time -Value "00:00:00"
                         Set-ItemProperty $appPoolPath -Name recycling.periodicRestart.requests -Value 0
                         Set-ItemProperty $appPoolPath -Name recycling.periodicRestart.memory -Value 0
                         Set-ItemProperty $appPoolPath -Name recycling.periodicRestart.privateMemory -Value 0
                         
                         # Advanced Configuration
                         Set-ItemProperty $appPoolPath -Name processModel.pingingEnabled -Value $true
                         Set-ItemProperty $appPoolPath -Name processModel.pingInterval -Value "00:00:30"
                         Set-ItemProperty $appPoolPath -Name processModel.pingResponseTime -Value "00:01:30"
                         Set-ItemProperty $appPoolPath -Name processModel.shutdownTimeLimit -Value "00:01:30"
                         Set-ItemProperty $appPoolPath -Name processModel.startupTimeLimit -Value "00:01:30"
                         
                         Write-Host "Application Pool configured: $($stakeholder.AppPool)" -ForegroundColor Green
                         
                         # ========== WEBSITE CONFIGURATION ==========
                         $websiteCreated = $false
                         if (-not (Get-Website -Name $stakeholder.SiteName -ErrorAction SilentlyContinue)) {
                           Write-Host "Creating Website: $($stakeholder.SiteName) on Port $($stakeholder.Port)" -ForegroundColor Yellow
                           New-Website -Name $stakeholder.SiteName -PhysicalPath $stakeholder.Path -ApplicationPool $stakeholder.AppPool -Port $stakeholder.Port
                           $websiteCreated = $true
                     } else {
                           Write-Host "Website exists, updating configuration: $($stakeholder.SiteName)" -ForegroundColor Gray
                           # Update the website configuration
                           Set-ItemProperty "IIS:\Sites\$($stakeholder.SiteName)" -Name applicationPool -Value $stakeholder.AppPool
                           Set-ItemProperty "IIS:\Sites\$($stakeholder.SiteName)" -Name physicalPath -Value $stakeholder.Path
                         }
                         
                         # Configure website bindings
                         $existingBinding = Get-WebBinding -Name $stakeholder.SiteName -Port $stakeholder.Port -ErrorAction SilentlyContinue
                         if (-not $existingBinding) {
                           New-WebBinding -Name $stakeholder.SiteName -Protocol "http" -Port $stakeholder.Port -IPAddress "*"
                           Write-Host "Added port binding for $($stakeholder.Port)" -ForegroundColor Yellow
                         }
                         
                         # Configure website settings
                         Set-ItemProperty "IIS:\Sites\$($stakeholder.SiteName)" -Name logFile.directory -Value "$(IISLogPath)"
                         Set-ItemProperty "IIS:\Sites\$($stakeholder.SiteName)" -Name logFile.enabled -Value $true
                         Set-ItemProperty "IIS:\Sites\$($stakeholder.SiteName)" -Name logFile.logFormat -Value "W3C"
                         
                         # Configure default document
                         $defaultDocs = @("default.aspx", "index.html", "default.htm")
                         foreach ($doc in $defaultDocs) {
                           try {
                             Add-WebConfigurationProperty -Filter "system.webServer/defaultDocument/files" -Name "." -Value @{value=$doc} -PSPath "IIS:\Sites\$($stakeholder.SiteName)"
                           } catch {
                             # Document already exists or error adding
                           }
                         }
                         
                         # Configure security headers (basic)
                         try {
                           Add-WebConfigurationProperty -Filter "system.webServer/httpProtocol/customHeaders" -Name "." -Value @{name="X-Content-Type-Options"; value="nosniff"} -PSPath "IIS:\Sites\$($stakeholder.SiteName)"
                           Add-WebConfigurationProperty -Filter "system.webServer/httpProtocol/customHeaders" -Name "." -Value @{name="X-Frame-Options"; value="SAMEORIGIN"} -PSPath "IIS:\Sites\$($stakeholder.SiteName)"
                         } catch {
                           # Headers might already exist
                         }
                         
                         $configurationResults += @{
                           Stakeholder = $stakeholder.Name
                           AppPoolCreated = $appPoolCreated
                           WebsiteCreated = $websiteCreated
                           Status = "Success"
                         }
                         
                         Write-Host "$($stakeholder.Name) infrastructure configured successfully" -ForegroundColor Green
                         
                       } catch {
                         Write-Error "Failed to configure $($stakeholder.Name): $($_.Exception.Message)"
                         $configurationResults += @{
                           Stakeholder = $stakeholder.Name
                           Status = "Failed"
                           Error = $_.Exception.Message
                         }
                       }
                     }
                     
                     # Summary
                     Write-Host "Infrastructure Configuration Summary:" -ForegroundColor Cyan
                     foreach ($result in $configurationResults) {
                       $statusColor = if ($result.Status -eq "Success") { "Green" } else { "Red" }
                       Write-Host "  $($result.Stakeholder): $($result.Status)" -ForegroundColor $statusColor
                     }
                     
                     Write-Host "All stakeholder infrastructure configured successfully!" -ForegroundColor Green
               
               # ==================== IN-PLACE DEPLOYMENT ====================
               # In-Place Deployment Strategy for Single Server:
               # 1. Backup current deployment
               # 2. Stop services gracefully
               # 3. Deploy new version
               # 4. Start services
               # 5. Verify deployment
               - task: PowerShell@2
                 displayName: 'Deploy to All Stakeholder Websites (In-Place)'
                 inputs:
                   targetType: 'inline'
                   script: |
                     $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                     $branchName = "$(BranchName)"
                     $buildNumber = "$(BuildNumber)"
                     
                     $stakeholders = @(
                       @{Name="$(Stakeholder1.Name)"; SiteName="$(Stakeholder1.SiteName)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder1.PhysicalPath)"; Port="$(Stakeholder1.Port)"; AppPool="$(Stakeholder1.AppPoolName)"},
                       @{Name="$(Stakeholder2.Name)"; SiteName="$(Stakeholder2.SiteName)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder2.PhysicalPath)"; Port="$(Stakeholder2.Port)"; AppPool="$(Stakeholder2.AppPoolName)"},
                       @{Name="$(Stakeholder3.Name)"; SiteName="$(Stakeholder3.SiteName)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder3.PhysicalPath)"; Port="$(Stakeholder3.Port)"; AppPool="$(Stakeholder3.AppPoolName)"},
                       @{Name="$(Stakeholder4.Name)"; SiteName="$(Stakeholder4.SiteName)"; Source="$(DeploymentBasePath)"; Dest="$(Stakeholder4.PhysicalPath)"; Port="$(Stakeholder4.Port)"; AppPool="$(Stakeholder4.AppPoolName)"}
                     )
                     
                     foreach ($stakeholder in $stakeholders) {
                       Write-Host "Deploying to $($stakeholder.Name) Website (Port: $($stakeholder.Port))" -ForegroundColor Cyan
                       Write-Host "Branch: $branchName | Build: $buildNumber" -ForegroundColor Gray
                       
                       # Clear and copy files
                       if (Test-Path $stakeholder.Dest) {
                         Get-ChildItem -Path $stakeholder.Dest -Exclude "App_Data" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
                       }
                       Copy-Item -Path "$($stakeholder.Source)\*" -Destination $stakeholder.Dest -Recurse -Force
                       
                       # Save deployment metadata with build information
                       $metadata = @{
                         DeploymentInfo = @{
                           StakeholderName = $stakeholder.Name
                           SiteName = $stakeholder.SiteName
                           AppPoolName = $stakeholder.AppPool
                           Description = $stakeholder.Description
                         }
                         BuildInfo = @{
                           BuildNumber = $buildNumber
                           BuildId = $buildId
                           BranchName = $branchName
                           CommitId = $commitId
                           BuildDate = "$(BuildDate)"
                           BuildTime = "$(BuildTime)"
                           DeploymentTimestamp = $timestamp
                         }
                         DeploymentDetails = @{
                           DeploymentPath = $stakeholder.Dest
                           Port = $stakeholder.Port
                           FolderName = "$($stakeholder.Name)_$branchName_$buildNumber"
                           Status = "Deployed"
                         }
                         EnvironmentInfo = @{
                           Environment = "$(Environment)"
                           DeploymentType = "$(DeploymentType)"
                           ServerName = $env:COMPUTERNAME
                           UserName = $env:USERNAME
                         }
                       }
                       
                       $metadataPath = "$(VersionMetadataPath)\$($stakeholder.Name)_Deployment_$timestamp.json"
                       $metadata | ConvertTo-Json -Depth 3 | Out-File -FilePath $metadataPath -Encoding UTF8
                       
                       Write-Host "$($stakeholder.Name) website deployed successfully" -ForegroundColor Green
                     }
               
               
               # ==================== SET PERMISSIONS ====================
               - task: PowerShell@2
                 displayName: 'Set Folder Permissions'
                 inputs:
                   targetType: 'inline'
                   script: |
                     $paths = @(
                       "$(Stakeholder1.PhysicalPath)",
                       "$(Stakeholder2.PhysicalPath)",
                       "$(Stakeholder3.PhysicalPath)",
                       "$(Stakeholder4.PhysicalPath)"
                     )
                     
                     foreach ($path in $paths) {
                       $acl = Get-Acl $path
                       
                       # Add IIS_IUSRS permission
                       $iisUsersRule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS","FullControl","ContainerInherit,ObjectInherit","None","Allow")
                       $acl.SetAccessRule($iisUsersRule)
                       
                       # Add IUSR permission
                       $iusrRule = New-Object System.Security.AccessControl.FileSystemAccessRule("IUSR","ReadAndExecute","ContainerInherit,ObjectInherit","None","Allow")
                       $acl.SetAccessRule($iusrRule)
                       
                       Set-Acl $path $acl
                       Write-Host "Permissions set for: $path" -ForegroundColor Green
                     }
               
               # ==================== IN-PLACE DEPLOYMENT: STOP SERVICES ====================
               - task: PowerShell@2
                 displayName: 'Stop Services for In-Place Deployment'
                 inputs:
                   targetType: 'inline'
                   script: |
                     Import-Module WebAdministration
                     
                     $stakeholders = @(
                       @{Name="$(Stakeholder1.Name)"; SiteName="$(Stakeholder1.SiteName)"; AppPool="$(Stakeholder1.AppPoolName)"},
                       @{Name="$(Stakeholder2.Name)"; SiteName="$(Stakeholder2.SiteName)"; AppPool="$(Stakeholder2.AppPoolName)"},
                       @{Name="$(Stakeholder3.Name)"; SiteName="$(Stakeholder3.SiteName)"; AppPool="$(Stakeholder3.AppPoolName)"},
                       @{Name="$(Stakeholder4.Name)"; SiteName="$(Stakeholder4.SiteName)"; AppPool="$(Stakeholder4.AppPoolName)"}
                     )
                     
                     foreach ($stakeholder in $stakeholders) {
                       Write-Host "Stopping $($stakeholder.Name) services..." -ForegroundColor Cyan
                       
                       # Stop website first
                       try {
                         Stop-Website -Name $stakeholder.SiteName -ErrorAction SilentlyContinue
                         Write-Host "Website stopped: $($stakeholder.SiteName)" -ForegroundColor Green
                       } catch {
                         Write-Host "Website was not running: $($stakeholder.SiteName)" -ForegroundColor Gray
                       }
                       
                       # Stop application pool
                       try {
                         Stop-WebAppPool -Name $stakeholder.AppPool -ErrorAction SilentlyContinue
                         
                         # Wait for app pool to stop
                         $timeout = 30
                         $elapsed = 0
                         while ((Get-WebAppPoolState -Name $stakeholder.AppPool).Value -ne "Stopped" -and $elapsed -lt $timeout) {
                           Start-Sleep -Seconds 1
                           $elapsed++
                         }
                         
                         if ((Get-WebAppPoolState -Name $stakeholder.AppPool).Value -eq "Stopped") {
                           Write-Host "Application pool stopped: $($stakeholder.AppPool)" -ForegroundColor Green
                         } else {
                           Write-Warning "Application pool did not stop within timeout: $($stakeholder.AppPool)"
                         }
                       } catch {
                         Write-Host "Application pool was not running: $($stakeholder.AppPool)" -ForegroundColor Gray
                       }
                     }
                     
                     Write-Host "All services stopped for in-place deployment" -ForegroundColor Green
                     Start-Sleep -Seconds 5  # Allow services to fully stop
               
               # ==================== IN-PLACE DEPLOYMENT: START SERVICES ====================
               - task: PowerShell@2
                 displayName: 'Start All Stakeholder Websites (In-Place)'
                 inputs:
                   targetType: 'inline'
                   script: |
                     Import-Module WebAdministration
                     
                     $stakeholders = @(
                       @{Name="$(Stakeholder1.Name)"; SiteName="$(Stakeholder1.SiteName)"; AppPool="$(Stakeholder1.AppPoolName)"},
                       @{Name="$(Stakeholder2.Name)"; SiteName="$(Stakeholder2.SiteName)"; AppPool="$(Stakeholder2.AppPoolName)"},
                       @{Name="$(Stakeholder3.Name)"; SiteName="$(Stakeholder3.SiteName)"; AppPool="$(Stakeholder3.AppPoolName)"},
                       @{Name="$(Stakeholder4.Name)"; SiteName="$(Stakeholder4.SiteName)"; AppPool="$(Stakeholder4.AppPoolName)"}
                     )
                     
                     foreach ($stakeholder in $stakeholders) {
                       Write-Host "Starting $($stakeholder.Name) website..." -ForegroundColor Cyan
                       
                       # Start Application Pool
                       Start-WebAppPool -Name $stakeholder.AppPool
                       Start-Sleep -Seconds 2
                       
                       # Start Website
                       Start-Website -Name $stakeholder.SiteName
                       
                       Write-Host "$($stakeholder.Name) website started successfully" -ForegroundColor Green
                     }
                     
                     Write-Host "All stakeholder websites started successfully!" -ForegroundColor Green

  # Post-deployment monitoring and cleanup
  - stage: PostDeployment
    displayName: 'Post-Deployment Activities'
    dependsOn: DeployStakeholderWebsites
    condition: succeeded()
    
    jobs:
      - job: PostDeploymentTasks
        displayName: 'Post-Deployment Tasks'
        steps:
               - task: PowerShell@2
            displayName: 'Generate Deployment Report'
                 inputs:
                   targetType: 'inline'
                   script: |
                # Generate comprehensive deployment report
                $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
                $reportPath = "$(LogsPath)\DeploymentReport_$timestamp.json"
                
                $deploymentReport = @{
                  DeploymentInfo = @{
                    BuildNumber = "$(BuildNumber)"
                    BranchName = "$(BranchName)"
                    BuildId = "$(BuildId)"
                    CommitId = "$(CommitId)"
                    DeploymentDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    Environment = "$(Environment)"
                    ServerName = $env:COMPUTERNAME
                  }
                  Stakeholders = @(
                    @{Name="$(Stakeholder1.Name)"; SiteName="$(Stakeholder1.SiteName)"; Port="$(Stakeholder1.Port)"; URL="http://localhost:$(Stakeholder1.Port)"},
                    @{Name="$(Stakeholder2.Name)"; SiteName="$(Stakeholder2.SiteName)"; Port="$(Stakeholder2.Port)"; URL="http://localhost:$(Stakeholder2.Port)"},
                    @{Name="$(Stakeholder3.Name)"; SiteName="$(Stakeholder3.SiteName)"; Port="$(Stakeholder3.Port)"; URL="http://localhost:$(Stakeholder3.Port)"},
                    @{Name="$(Stakeholder4.Name)"; SiteName="$(Stakeholder4.SiteName)"; Port="$(Stakeholder4.Port)"; URL="http://localhost:$(Stakeholder4.Port)"}
                  )
                  Paths = @{
                    DeploymentBase = "$(DeploymentBasePath)"
                    BackupBase = "$(BackupBasePath)"
                    MetadataBase = "$(VersionMetadataPath)"
                    LogsBase = "$(LogsPath)"
                  }
                }
                
                $deploymentReport | ConvertTo-Json -Depth 5 | Out-File -FilePath $reportPath -Encoding UTF8
                Write-Host "Deployment report generated: $reportPath" -ForegroundColor Green
                
               - task: PowerShell@2
            displayName: 'Cleanup Temporary Files'
                 inputs:
                   targetType: 'inline'
                   script: |
                # Cleanup temporary deployment files
                $tempPaths = @("$(DeploymentBasePath)")
                
                foreach ($path in $tempPaths) {
                  if (Test-Path $path) {
                    $tempFiles = Get-ChildItem $path -Recurse -File | Where-Object { $_.Extension -in @('.tmp', '.temp', '.log') }
                    foreach ($file in $tempFiles) {
                      try {
                        Remove-Item $file.FullName -Force
                        Write-Host "Removed temporary file: $($file.Name)" -ForegroundColor Gray
                       } catch {
                        Write-Warning "Could not remove temporary file: $($file.Name)"
                      }
                    }
                  }
                }
                
                Write-Host "Temporary files cleanup completed" -ForegroundColor Green

  # ==================== REDEPLOY PREVIOUS BUILD ====================
  - stage: RedeployPreviousBuild
    displayName: 'Redeploy Previous Build (Manual Trigger)'
    condition: and(succeeded(), eq(variables['Build.Reason'], 'Manual'))
    jobs:
      - job: RedeployBuild
        displayName: 'Redeploy Previous Working Build'
        steps:
          - task: PowerShell@2
            displayName: 'Redeploy Previous Build Instructions'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "========================================" -ForegroundColor Cyan
                Write-Host "Redeploy Previous Build Instructions" -ForegroundColor Cyan
                Write-Host "========================================" -ForegroundColor Cyan
                Write-Host ""
                Write-Host "To redeploy a previous working build:" -ForegroundColor Yellow
                Write-Host ""
                Write-Host "1. Go to Azure DevOps Portal" -ForegroundColor White
                Write-Host "2. Navigate to: Pipelines → Your Pipeline" -ForegroundColor White
                Write-Host "3. Click 'Run pipeline' button" -ForegroundColor White
                Write-Host "4. Select the branch with the working build" -ForegroundColor White
                Write-Host "5. Choose the specific commit/build you want to redeploy" -ForegroundColor White
                Write-Host "6. Click 'Run' to redeploy that exact build" -ForegroundColor White
                Write-Host ""
                Write-Host "Current Build Information:" -ForegroundColor Yellow
                Write-Host "  Build Number: $(BuildNumber)" -ForegroundColor Gray
                Write-Host "  Branch: $(BranchName)" -ForegroundColor Gray
                Write-Host "  Commit ID: $(CommitId)" -ForegroundColor Gray
                Write-Host "  Build Date: $(BuildDate) $(BuildTime)" -ForegroundColor Gray
                Write-Host ""
                Write-Host "Benefits of Redeploying Previous Build:" -ForegroundColor Green
                Write-Host "  ✓ Clean deployment with fresh files" -ForegroundColor Green
                Write-Host "  ✓ No file corruption or missing files" -ForegroundColor Green
                Write-Host "  ✓ Goes through full validation process" -ForegroundColor Green
                Write-Host "  ✓ Proper audit trail and logging" -ForegroundColor Green
                Write-Host "  ✓ Consistent deployment state" -ForegroundColor Green
                Write-Host ""
                Write-Host "========================================" -ForegroundColor Cyan
                     }